#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

#[cfg(test)]
use std::{ffi::CString, mem::MaybeUninit};

/* automatically generated by rust-bindgen 0.69.1 */

pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const ON: u32 = 1;
pub const OFF: u32 = 0;
pub const EXIP_DEBUG: u32 = 1;
pub const DEBUG_STREAM_IO: u32 = 0;
pub const DEBUG_COMMON: u32 = 0;
pub const DEBUG_CONTENT_IO: u32 = 0;
pub const DEBUG_GRAMMAR: u32 = 0;
pub const DEBUG_GRAMMAR_GEN: u32 = 0;
pub const DEBUG_STRING_TBLS: u32 = 0;
pub const _ASSERT_H: u32 = 1;
pub const HASH_TABLE_USE: u32 = 1;
pub const INITIAL_HASH_TABLE_SIZE: u32 = 6151;
pub const MAX_HASH_TABLE_SIZE: u32 = 32000;
pub const DYN_ARRAY_USE: u32 = 1;
pub const GR_VOID_NON_TERMINAL: u32 = 16777215;
pub const EXIP_IMPLICIT_DATA_TYPE_CONVERSION: u32 = 1;
pub const EXI_PROFILE_DEFAULT: u32 = 0;
pub const VALUE_CROSSTABLE_USE: u32 = 1;
pub const BUILD_IN_GRAMMARS_USE: u32 = 1;
pub const INFO: u32 = 1;
pub const WARNING: u32 = 2;
pub const ERROR: u32 = 3;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const BIT_PACKED: u32 = 0;
pub const BYTE_ALIGNMENT: u32 = 64;
pub const PRE_COMPRESSION: u32 = 128;
pub const ALIGNMENT: u32 = 192;
pub const COMPRESSION: u32 = 1;
pub const STRICT: u32 = 2;
pub const FRAGMENT: u32 = 4;
pub const SELF_CONTAINED: u32 = 8;
pub const PRESERVE_COMMENTS: u32 = 1;
pub const PRESERVE_PIS: u32 = 2;
pub const PRESERVE_DTD: u32 = 4;
pub const PRESERVE_PREFIXES: u32 = 8;
pub const PRESERVE_LEXVALUES: u32 = 16;
pub const MAXIMUM_NUMBER_OF_PREFIXES_PER_URI: u32 = 4;
pub const TZONE_PRESENCE: u32 = 1;
pub const FRACT_PRESENCE: u32 = 2;
pub const EXIP_INDEX_MAX: i32 = -1;
pub const INDEX_MAX: i32 = -1;
pub const EXIP_SMALL_INDEX_MAX: i32 = -1;
pub const SMALL_INDEX_MAX: i32 = -1;
pub const URI_MAX: i32 = -1;
pub const LN_MAX: i32 = -1;
pub const ALLOCATION_ARRAY_SIZE: u32 = 100;
pub const PROD_CONTENT_MASK: u32 = 16777215;
pub const GR_DOC_CONTENT: u32 = 0;
pub const GR_DOC_END: u32 = 1;
pub const GR_START_TAG_CONTENT: u32 = 0;
pub const GR_ELEMENT_CONTENT: u32 = 1;
pub const GR_CONTENT_2: u32 = 16777214;
pub const GR_FRAGMENT_CONTENT: u32 = 0;
pub const RULE_CONTAIN_EE_OR_XSI_TYPE_MASK: u32 = 1;
pub const GR_PROP_BUILT_IN_ELEMENT: u32 = 16777216;
pub const GR_PROP_SCHEMA_INFORMED: u32 = 33554432;
pub const GR_PROP_DOCUMENT: u32 = 67108864;
pub const GR_PROP_FRAGMENT: u32 = 134217728;
pub const GR_PROP_NILLABLE: u32 = 268435456;
pub const GR_PROP_NAMED_SUB_TYPE_OR_UNION: u32 = 536870912;
pub const GR_PROP_HAS_CONTENT2: u32 = 1073741824;
pub const GR_CONTENT_INDEX_MASK: u32 = 16777215;
pub const TYPE_FACET_LENGTH: u32 = 1;
pub const TYPE_FACET_MIN_LENGTH: u32 = 2;
pub const TYPE_FACET_MAX_LENGTH: u32 = 4;
pub const TYPE_FACET_PATTERN: u32 = 8;
pub const TYPE_FACET_ENUMERATION: u32 = 16;
pub const TYPE_FACET_WHITE_SPACE: u32 = 32;
pub const TYPE_FACET_MAX_INCLUSIVE: u32 = 64;
pub const TYPE_FACET_MAX_EXCLUSIVE: u32 = 128;
pub const TYPE_FACET_MIN_EXCLUSIVE: u32 = 256;
pub const TYPE_FACET_MIN_INCLUSIVE: u32 = 512;
pub const TYPE_FACET_TOTAL_DIGITS: u32 = 1024;
pub const TYPE_FACET_FRACTION_DIGITS: u32 = 2048;
pub const TYPE_FACET_NAMED_SUBTYPE_UNION: u32 = 4096;
pub const ST_CONTENT_MASK: u32 = 16777215;
pub const SIMPLE_TYPE_ENTITIES: u32 = 0;
pub const SIMPLE_TYPE_ENTITY: u32 = 1;
pub const SIMPLE_TYPE_ID: u32 = 2;
pub const SIMPLE_TYPE_IDREF: u32 = 3;
pub const SIMPLE_TYPE_IDREFS: u32 = 4;
pub const SIMPLE_TYPE_NCNAME: u32 = 5;
pub const SIMPLE_TYPE_NMTOKEN: u32 = 6;
pub const SIMPLE_TYPE_NMTOKENS: u32 = 7;
pub const SIMPLE_TYPE_NOTATION: u32 = 8;
pub const SIMPLE_TYPE_NAME: u32 = 9;
pub const SIMPLE_TYPE_QNAME: u32 = 10;
pub const SIMPLE_TYPE_ANY_SIMPLE_TYPE: u32 = 11;
pub const SIMPLE_TYPE_ANY_TYPE: u32 = 12;
pub const SIMPLE_TYPE_ANY_URI: u32 = 13;
pub const SIMPLE_TYPE_BASE64_BINARY: u32 = 14;
pub const SIMPLE_TYPE_BOOLEAN: u32 = 15;
pub const SIMPLE_TYPE_BYTE: u32 = 16;
pub const SIMPLE_TYPE_DATE: u32 = 17;
pub const SIMPLE_TYPE_DATE_TIME: u32 = 18;
pub const SIMPLE_TYPE_DECIMAL: u32 = 19;
pub const SIMPLE_TYPE_DOUBLE: u32 = 20;
pub const SIMPLE_TYPE_DURATION: u32 = 21;
pub const SIMPLE_TYPE_FLOAT: u32 = 22;
pub const SIMPLE_TYPE_GDAY: u32 = 23;
pub const SIMPLE_TYPE_GMONTH: u32 = 24;
pub const SIMPLE_TYPE_GMONTH_DAY: u32 = 25;
pub const SIMPLE_TYPE_GYEAR: u32 = 26;
pub const SIMPLE_TYPE_GYEAR_MONTH: u32 = 27;
pub const SIMPLE_TYPE_HEX_BINARY: u32 = 28;
pub const SIMPLE_TYPE_INT: u32 = 29;
pub const SIMPLE_TYPE_INTEGER: u32 = 30;
pub const SIMPLE_TYPE_LANGUAGE: u32 = 31;
pub const SIMPLE_TYPE_LONG: u32 = 32;
pub const SIMPLE_TYPE_NEGATIVE_INTEGER: u32 = 33;
pub const SIMPLE_TYPE_NON_NEGATIVE_INTEGER: u32 = 34;
pub const SIMPLE_TYPE_NON_POSITIVE_INTEGER: u32 = 35;
pub const SIMPLE_TYPE_NORMALIZED_STRING: u32 = 36;
pub const SIMPLE_TYPE_POSITIVE_INTEGER: u32 = 37;
pub const SIMPLE_TYPE_SHORT: u32 = 38;
pub const SIMPLE_TYPE_STRING: u32 = 39;
pub const SIMPLE_TYPE_TIME: u32 = 40;
pub const SIMPLE_TYPE_TOKEN: u32 = 41;
pub const SIMPLE_TYPE_UNSIGNED_BYTE: u32 = 42;
pub const SIMPLE_TYPE_UNSIGNED_INT: u32 = 43;
pub const SIMPLE_TYPE_UNSIGNED_LONG: u32 = 44;
pub const SIMPLE_TYPE_UNSIGNED_SHORT: u32 = 45;
pub const SIMPLE_TYPE_COUNT: u32 = 46;
pub const XML_NAMESPACE_ID: u32 = 1;
pub const XML_SCHEMA_INSTANCE_ID: u32 = 2;
pub const XML_SCHEMA_INSTANCE_NIL_ID: u32 = 0;
pub const XML_SCHEMA_INSTANCE_TYPE_ID: u32 = 1;
pub const XML_SCHEMA_NAMESPACE_ID: u32 = 3;
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " No error, everything is OK."]
pub const errorCode_EXIP_OK: errorCode = 0;
#[doc = " The code for this function\n is not yet implemented."]
pub const errorCode_EXIP_NOT_IMPLEMENTED_YET: errorCode = 1;
#[doc = " Any error that does not fall\n into the other categories"]
pub const errorCode_EXIP_UNEXPECTED_ERROR: errorCode = 2;
#[doc = " Hash table error"]
pub const errorCode_EXIP_HASH_TABLE_ERROR: errorCode = 3;
#[doc = " Array out of bound"]
pub const errorCode_EXIP_OUT_OF_BOUND_BUFFER: errorCode = 4;
#[doc = " Try to access null pointer"]
pub const errorCode_EXIP_NULL_POINTER_REF: errorCode = 5;
#[doc = " Unsuccessful memory allocation"]
pub const errorCode_EXIP_MEMORY_ALLOCATION_ERROR: errorCode = 6;
#[doc = " Error in the EXI header"]
pub const errorCode_EXIP_INVALID_EXI_HEADER: errorCode = 7;
#[doc = " Processor state is inconsistent\n with the stream events"]
pub const errorCode_EXIP_INCONSISTENT_PROC_STATE: errorCode = 8;
#[doc = " Received EXI value type or event\n encoding that is invalid according\n to the specification"]
pub const errorCode_EXIP_INVALID_EXI_INPUT: errorCode = 9;
#[doc = " Buffer end reached"]
pub const errorCode_EXIP_BUFFER_END_REACHED: errorCode = 10;
#[doc = " Buffer end reached"]
pub const errorCode_EXIP_PARSING_COMPLETE: errorCode = 11;
#[doc = " The number MAXIMUM_NUMBER_OF_PREFIXES_PER_URI\n is reached - must be increased in the build"]
pub const errorCode_EXIP_TOO_MANY_PREFIXES_PER_URI: errorCode = 12;
#[doc = " The information passed to\n the EXIP API is invalid"]
pub const errorCode_EXIP_INVALID_EXIP_CONFIGURATION: errorCode = 13;
#[doc = " When encoding XML Schema in EXI the prefixes must be preserved:\n When qualified namesNS are used in the values of AT or CH events in an EXI Stream,\n the Preserve.prefixes fidelity option SHOULD be turned on to enable the preservation of\n the NS prefix declarations used by these values. Note, in particular among other cases,\n that this practice applies to the use of xsi:type attributes in EXI streams when Preserve.lexicalValues\n fidelity option is set to true."]
pub const errorCode_EXIP_NO_PREFIXES_PRESERVED_XML_SCHEMA: errorCode = 14;
#[doc = " When encoding XML Schema in EXI the prefixes must be preserved:\n When qualified namesNS are used in the values of AT or CH events in an EXI Stream,\n the Preserve.prefixes fidelity option SHOULD be turned on to enable the preservation of\n the NS prefix declarations used by these values. Note, in particular among other cases,\n that this practice applies to the use of xsi:type attributes in EXI streams when Preserve.lexicalValues\n fidelity option is set to true."]
pub const errorCode_EXIP_INVALID_STRING_OPERATION: errorCode = 15;
#[doc = " Mismatch in the header options.\n This error can be due to:\n 1) The \"alignment\" element MUST NOT appear in an EXI options document when the \"compression\" element is present;\n 2) The \"strict\" element MUST NOT appear in an EXI options document when one of \"dtd\", \"prefixes\",\n \"comments\", \"pis\" or \"selfContained\" element is present in the same options document. That is only the\n element \"lexicalValues\", from the fidelity options, is permitted to occur in the presence of \"strict\" element;\n 3) The \"selfContained\" element MUST NOT appear in an EXI options document when one of \"compression\",\n \"pre-compression\" or \"strict\" elements are present in the same options document.\n 4) The  datatypeRepresentationMap option does not take effect when the value of the Preserve.lexicalValues\n fidelity option is true (see 6.3 Fidelity Options), or when the EXI stream is a schema-less EXI stream.\n 5) Presence Bit for EXI Options not set and no out-of-band options set"]
pub const errorCode_EXIP_HEADER_OPTIONS_MISMATCH: errorCode = 16;
#[doc = " Send a signal to the EXIP parser from a content handler callback\n for gracefully stopping the EXI stream parsing."]
pub const errorCode_EXIP_HANDLER_STOP: errorCode = 17;
pub type errorCode = ::std::os::raw::c_uint;
extern "C" {
    pub static mut errorCodeStrings: [*const ::std::os::raw::c_char; 0usize];
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub const boolean_FALSE: boolean = 0;
pub const boolean_TRUE: boolean = 1;
pub type boolean = ::std::os::raw::c_uint;
#[doc = " An item in a Generic Stack structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stackNode {
    pub item: *mut ::std::os::raw::c_void,
    pub nextInStack: *mut stackNode,
}
#[test]
fn bindgen_test_layout_stackNode() {
    const UNINIT: ::std::mem::MaybeUninit<stackNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stackNode>(),
        16usize,
        concat!("Size of: ", stringify!(stackNode))
    );
    assert_eq!(
        ::std::mem::align_of::<stackNode>(),
        8usize,
        concat!("Alignment of ", stringify!(stackNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).item) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stackNode),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nextInStack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stackNode),
            "::",
            stringify!(nextInStack)
        )
    );
}
#[doc = " An item in a Generic Stack structure"]
pub type GenericStack = stackNode;
pub const SchemaIdMode_SCHEMA_ID_ABSENT: SchemaIdMode = 0;
pub const SchemaIdMode_SCHEMA_ID_SET: SchemaIdMode = 1;
pub const SchemaIdMode_SCHEMA_ID_NIL: SchemaIdMode = 2;
pub const SchemaIdMode_SCHEMA_ID_EMPTY: SchemaIdMode = 3;
#[doc = " @name Handling of SchemaID header field\n\n SchemaID option modes:\n @def SCHEMA_ID_ABSENT\n \t\tdefault,  no statement is made about the schema information\n @def SCHEMA_ID_SET\n \t\tsome sting identification of the schema is given\n @def SCHEMA_ID_NIL\n \t\tno schema information is used for processing the EXI body (i.e. a schema-less EXI stream)\n @def SCHEMA_ID_EMPTY\n \t\tno user defined schema information is used for processing the EXI body; however, the built-in XML schema types are available for use in the EXI body\n\n @see http://www.w3.org/TR/2011/REC-exi-20110310/#key-schemaIdOption"]
pub type SchemaIdMode = ::std::os::raw::c_uint;
#[doc = " Fractional seconds = value * 10^-(offset+1) seconds;\n Example:\n offset = 4\n value = 123\n Fractional seconds = 123×10^−5 = 0.00123 seconds = 1.23 milliseconds\n @note (offset+1) must be greater or equal than the number of digits in value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fractionalSecs {
    pub offset: ::std::os::raw::c_uchar,
    pub value: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_fractionalSecs() {
    const UNINIT: ::std::mem::MaybeUninit<fractionalSecs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fractionalSecs>(),
        8usize,
        concat!("Size of: ", stringify!(fractionalSecs))
    );
    assert_eq!(
        ::std::mem::align_of::<fractionalSecs>(),
        4usize,
        concat!("Alignment of ", stringify!(fractionalSecs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fractionalSecs),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fractionalSecs),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Fractional seconds = value * 10^-(offset+1) seconds;\n Example:\n offset = 4\n value = 123\n Fractional seconds = 123×10^−5 = 0.00123 seconds = 1.23 milliseconds\n @note (offset+1) must be greater or equal than the number of digits in value"]
pub type FractionalSecs = fractionalSecs;
#[doc = " DateTime type in EXIP.\n Contains a standard \"struct tm\" combined with\n fractional seconds and presence mask."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXIPDateTime {
    #[doc = " As defined in time.h\n @note Decoding functions set negative values (INT_MIN) for the fields that are not available\n\n int    tm_sec   seconds [0,61]\n int    tm_min   minutes [0,59]\n int    tm_hour  hour [0,23]\n int    tm_mday  day of month [1,31]\n int    tm_mon   month of year [0,11]\n int    tm_year  years since 1900\n int    tm_wday  day of week [0,6] (Sunday = 0)\n int    tm_yday  day of year [0,365]\n int    tm_isdst daylight savings flag"]
    pub dateTime: tm,
    pub fSecs: FractionalSecs,
    #[doc = " TZHours * 64 + TZMinutes. Where:\n TZHours is a value in the range [-14 .. 14] and represents the\n standard notion of tize zone as an offset from UTC.\n TZMinutes is a value in the range [-59 .. 59] and\n could be used for minute based time zones."]
    pub TimeZone: i16,
    #[doc = " Whether to included fractional seconds and timeZone information\n Use FRACT_PRESENCE and TZONE_PRESENCE masks\n and IS_PRESENT() macro. Always initialize this to 0;"]
    pub presenceMask: u8,
}
#[test]
fn bindgen_test_layout_EXIPDateTime() {
    const UNINIT: ::std::mem::MaybeUninit<EXIPDateTime> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EXIPDateTime>(),
        72usize,
        concat!("Size of: ", stringify!(EXIPDateTime))
    );
    assert_eq!(
        ::std::mem::align_of::<EXIPDateTime>(),
        8usize,
        concat!("Alignment of ", stringify!(EXIPDateTime))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dateTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIPDateTime),
            "::",
            stringify!(dateTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fSecs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIPDateTime),
            "::",
            stringify!(fSecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeZone) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIPDateTime),
            "::",
            stringify!(TimeZone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).presenceMask) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIPDateTime),
            "::",
            stringify!(presenceMask)
        )
    );
}
pub type UnsignedInteger = u64;
pub type Integer = i64;
#[doc = " Represents base 10 (decimal) floating-point data.\n The default Float representation in EXIP.\n Maps directly to the EXI Float datatype.\n Used for float and decimal data.\n\n @see http://www.w3.org/TR/2011/REC-exi-20110310/#encodingFloat"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXIFloat {
    pub mantissa: i64,
    pub exponent: i16,
}
#[test]
fn bindgen_test_layout_EXIFloat() {
    const UNINIT: ::std::mem::MaybeUninit<EXIFloat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EXIFloat>(),
        16usize,
        concat!("Size of: ", stringify!(EXIFloat))
    );
    assert_eq!(
        ::std::mem::align_of::<EXIFloat>(),
        8usize,
        concat!("Alignment of ", stringify!(EXIFloat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mantissa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIFloat),
            "::",
            stringify!(mantissa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exponent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIFloat),
            "::",
            stringify!(exponent)
        )
    );
}
#[doc = " Represents base 10 (decimal) floating-point data.\n The default Float representation in EXIP.\n Maps directly to the EXI Float datatype.\n Used for float and decimal data.\n\n @see http://www.w3.org/TR/2011/REC-exi-20110310/#encodingFloat"]
pub type Float = EXIFloat;
#[doc = " Represents base 10 (decimal) floating-point data.\n The default Float representation in EXIP.\n Maps directly to the EXI Float datatype.\n Used for float and decimal data.\n\n @see http://www.w3.org/TR/2011/REC-exi-20110310/#encodingFloat"]
pub type Decimal = Float;
pub type Index = usize;
pub type SmallIndex = usize;
pub type CharType = ::std::os::raw::c_char;
#[doc = " Represents the length prefixed strings in EXIP"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StringType {
    pub str_: *mut CharType,
    pub length: Index,
}

impl StringType {
    pub fn empty() -> Self {
        StringType {
            str_: std::ptr::null::<std::os::raw::c_char>() as *mut _,
            length: 0,
        }
    }
}
#[test]
fn bindgen_test_layout_StringType() {
    const UNINIT: ::std::mem::MaybeUninit<StringType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StringType>(),
        16usize,
        concat!("Size of: ", stringify!(StringType))
    );
    assert_eq!(
        ::std::mem::align_of::<StringType>(),
        8usize,
        concat!("Alignment of ", stringify!(StringType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StringType),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(StringType),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " Represents the length prefixed strings in EXIP"]
pub type String = StringType;
#[doc = " Represent a fully qualified name"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QName {
    #[doc = " Pointer to a String value in the URI string table.\n @note It is not allowed to modify the string table content from this pointer."]
    pub uri: *const String,
    #[doc = " Pointer to a String value in the LN sting table.\n @note It is not allowed to modify the string table content from this pointer."]
    pub localName: *const String,
    #[doc = " Pointer to a String value in the Prefix string table if [Preserve prefixes] is TRUE and NULL otherwise.\n @note It is not allowed to modify the string table content from this pointer."]
    pub prefix: *const String,
}
#[test]
fn bindgen_test_layout_QName() {
    const UNINIT: ::std::mem::MaybeUninit<QName> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<QName>(),
        24usize,
        concat!("Size of: ", stringify!(QName))
    );
    assert_eq!(
        ::std::mem::align_of::<QName>(),
        8usize,
        concat!("Alignment of ", stringify!(QName))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uri) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QName),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QName),
            "::",
            stringify!(localName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(QName),
            "::",
            stringify!(prefix)
        )
    );
}
#[doc = " Position of a qname in the string tables"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QNameID {
    pub uriId: SmallIndex,
    pub lnId: Index,
}
#[test]
fn bindgen_test_layout_QNameID() {
    const UNINIT: ::std::mem::MaybeUninit<QNameID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<QNameID>(),
        16usize,
        concat!("Size of: ", stringify!(QNameID))
    );
    assert_eq!(
        ::std::mem::align_of::<QNameID>(),
        8usize,
        concat!("Alignment of ", stringify!(QNameID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uriId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QNameID),
            "::",
            stringify!(uriId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lnId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QNameID),
            "::",
            stringify!(lnId)
        )
    );
}
#[doc = " An array of allocation pointers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct allocBlock {
    pub allocation: [*mut ::std::os::raw::c_void; 100usize],
    pub nextBlock: *mut allocBlock,
}
#[test]
fn bindgen_test_layout_allocBlock() {
    const UNINIT: ::std::mem::MaybeUninit<allocBlock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<allocBlock>(),
        808usize,
        concat!("Size of: ", stringify!(allocBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<allocBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(allocBlock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(allocBlock),
            "::",
            stringify!(allocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nextBlock) as usize - ptr as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(allocBlock),
            "::",
            stringify!(nextBlock)
        )
    );
}
#[doc = " A list of allocation blocks.\n Pass to initAllocList() before use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct allocList {
    pub firstBlock: *mut allocBlock,
    pub lastBlock: *mut allocBlock,
    #[doc = " The next allocation slot in the allocation array of the lastBlock"]
    pub currAllocSlot: SmallIndex,
}
#[test]
fn bindgen_test_layout_allocList() {
    const UNINIT: ::std::mem::MaybeUninit<allocList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<allocList>(),
        24usize,
        concat!("Size of: ", stringify!(allocList))
    );
    assert_eq!(
        ::std::mem::align_of::<allocList>(),
        8usize,
        concat!("Alignment of ", stringify!(allocList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firstBlock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(allocList),
            "::",
            stringify!(firstBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastBlock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(allocList),
            "::",
            stringify!(lastBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currAllocSlot) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(allocList),
            "::",
            stringify!(currAllocSlot)
        )
    );
}
#[doc = " A list of allocation blocks.\n Pass to initAllocList() before use."]
pub type AllocList = allocList;
#[doc = " Meta-data of generic dynamic array.\n A concrete dynamic array is defined as follow:\n @code\n   struct [ConcreteDynamicArray]\n   {\n     DynArray dynArray;\n     [ArrayEntryType]* base;\n     Index count;\n   };\n @endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dynArray {
    #[doc = " The size of an entry in bytes"]
    pub entrySize: usize,
    #[doc = " The initial size of the dynamic array (in number of entries),\n also the chunk of number of entries to be added each expansion time"]
    pub chunkEntries: Index,
    #[doc = " The total number of entries in the array"]
    pub arrayEntries: Index,
}
#[test]
fn bindgen_test_layout_dynArray() {
    const UNINIT: ::std::mem::MaybeUninit<dynArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dynArray>(),
        24usize,
        concat!("Size of: ", stringify!(dynArray))
    );
    assert_eq!(
        ::std::mem::align_of::<dynArray>(),
        8usize,
        concat!("Alignment of ", stringify!(dynArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entrySize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dynArray),
            "::",
            stringify!(entrySize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chunkEntries) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dynArray),
            "::",
            stringify!(chunkEntries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrayEntries) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dynArray),
            "::",
            stringify!(arrayEntries)
        )
    );
}
#[doc = " Meta-data of generic dynamic array.\n A concrete dynamic array is defined as follow:\n @code\n   struct [ConcreteDynamicArray]\n   {\n     DynArray dynArray;\n     [ArrayEntryType]* base;\n     Index count;\n   };\n @endcode"]
pub type DynArray = dynArray;
pub const EventType_EVENT_SD: EventType = 0;
pub const EventType_EVENT_ED: EventType = 10;
pub const EventType_EVENT_AT_QNAME: EventType = 20;
pub const EventType_EVENT_AT_URI: EventType = 21;
pub const EventType_EVENT_AT_ALL: EventType = 22;
pub const EventType_EVENT_SE_QNAME: EventType = 30;
pub const EventType_EVENT_SE_URI: EventType = 31;
pub const EventType_EVENT_SE_ALL: EventType = 32;
pub const EventType_EVENT_EE: EventType = 40;
pub const EventType_EVENT_CH: EventType = 50;
pub const EventType_EVENT_NS: EventType = 60;
pub const EventType_EVENT_CM: EventType = 70;
pub const EventType_EVENT_PI: EventType = 80;
pub const EventType_EVENT_DT: EventType = 90;
pub const EventType_EVENT_ER: EventType = 100;
pub const EventType_EVENT_SC: EventType = 110;
#[doc = " Indicates lack of Terminal symbol in proto-grammars"]
pub const EventType_EVENT_VOID: EventType = 255;
#[doc = " Event types that occur in an EXI stream. This is moved from the grammar module because\n of the added \"Void\" element.\n\n <table>\n <tr><th>Name</th><th>Notation</th><th>Value</th></tr>\n <tr><td>Start Document</td><td>SD         </td><td> 0</td></tr>\n <tr><td>End Document  </td><td>ED         </td><td>10</td></tr>\n <tr><td>Start Element </td><td>SE( qname )</td><td>20</td></tr>\n <tr><td>Start Element </td><td>SE( uri:* )</td><td>21</td></tr>\n <tr><td>Start Element </td><td>SE( * )    </td><td>22</td></tr>\n <tr><td>End Element   </td><td>EE         </td><td>30</td></tr>\n <tr><td>Attribute     </td><td>AT( qname )</td><td>31</td></tr>\n <tr><td>Attribute     </td><td>AT( uri:* )</td><td>32</td></tr>\n <tr><td>Attribute     </td><td>AT( * )    </td><td>40</td></tr>\n <tr><td>Characters    </td><td>CH         </td><td>50</td></tr>\n <tr><td>Namespace Decl</td><td>NS         </td><td>60</td></tr>\n <tr><td>Comment       </td><td>CM         </td><td>70</td></tr>\n <tr><td>Processng Inst</td><td>PI         </td><td>80</td></tr>\n <tr><td>DOCTYPE       </td><td>DT         </td><td>90</td></tr>\n <tr><td>Entity Refrnce</td><td>ER         </td><td>100</td></tr>\n <tr><td>Self-contained</td><td>SC         </td><td>110</td></tr>\n <tr><td>Void          </td><td>--         </td><td>255</td></tr>\n </table>"]
pub type EventType = ::std::os::raw::c_uint;
pub const EventTypeClass_EVENT_SD_CLASS: EventTypeClass = 0;
pub const EventTypeClass_EVENT_ED_CLASS: EventTypeClass = 1;
pub const EventTypeClass_EVENT_AT_CLASS: EventTypeClass = 2;
pub const EventTypeClass_EVENT_SE_CLASS: EventTypeClass = 3;
pub const EventTypeClass_EVENT_EE_CLASS: EventTypeClass = 4;
pub const EventTypeClass_EVENT_CH_CLASS: EventTypeClass = 5;
pub const EventTypeClass_EVENT_NS_CLASS: EventTypeClass = 6;
pub const EventTypeClass_EVENT_CM_CLASS: EventTypeClass = 7;
pub const EventTypeClass_EVENT_PI_CLASS: EventTypeClass = 8;
pub const EventTypeClass_EVENT_DT_CLASS: EventTypeClass = 9;
pub const EventTypeClass_EVENT_ER_CLASS: EventTypeClass = 10;
pub const EventTypeClass_EVENT_SC_CLASS: EventTypeClass = 11;
pub const EventTypeClass_EVENT_VOID_CLASS: EventTypeClass = 25;
pub type EventTypeClass = ::std::os::raw::c_uint;
pub const EXIType_VALUE_TYPE_NONE: EXIType = 0;
pub const EXIType_VALUE_TYPE_STRING: EXIType = 10;
pub const EXIType_VALUE_TYPE_FLOAT: EXIType = 20;
pub const EXIType_VALUE_TYPE_DECIMAL: EXIType = 30;
pub const EXIType_VALUE_TYPE_DATE_TIME: EXIType = 40;
#[doc = " Used for xs:gYear type"]
pub const EXIType_VALUE_TYPE_YEAR: EXIType = 41;
#[doc = " Used for xs:gYearMonth and xs:date types"]
pub const EXIType_VALUE_TYPE_DATE: EXIType = 42;
#[doc = " Used for xs:gMonth, xs:gMonthDay and xs:gDay types"]
pub const EXIType_VALUE_TYPE_MONTH: EXIType = 43;
#[doc = " Used for xs:time type"]
pub const EXIType_VALUE_TYPE_TIME: EXIType = 44;
#[doc = " Used for xs:time type"]
pub const EXIType_VALUE_TYPE_BOOLEAN: EXIType = 50;
#[doc = " Used for xs:time type"]
pub const EXIType_VALUE_TYPE_BINARY: EXIType = 60;
#[doc = " Used for xs:time type"]
pub const EXIType_VALUE_TYPE_LIST: EXIType = 70;
#[doc = " Used for xs:time type"]
pub const EXIType_VALUE_TYPE_QNAME: EXIType = 80;
#[doc = " Used for xs:time type"]
pub const EXIType_VALUE_TYPE_INTEGER: EXIType = 90;
#[doc = " Used for xs:time type"]
pub const EXIType_VALUE_TYPE_SMALL_INTEGER: EXIType = 91;
#[doc = " Used for xs:time type"]
pub const EXIType_VALUE_TYPE_NON_NEGATIVE_INT: EXIType = 92;
#[doc = " Used for xs:time type"]
pub const EXIType_VALUE_TYPE_UNTYPED: EXIType = 255;
#[doc = " This is the type of the \"value\" content of EXI events. It is used when schema is available."]
pub type EXIType = ::std::os::raw::c_uint;
pub const EXITypeClass_VALUE_TYPE_NONE_CLASS: EXITypeClass = 0;
pub const EXITypeClass_VALUE_TYPE_STRING_CLASS: EXITypeClass = 1;
pub const EXITypeClass_VALUE_TYPE_FLOAT_CLASS: EXITypeClass = 2;
pub const EXITypeClass_VALUE_TYPE_DECIMAL_CLASS: EXITypeClass = 3;
pub const EXITypeClass_VALUE_TYPE_DATE_TIME_CLASS: EXITypeClass = 4;
pub const EXITypeClass_VALUE_TYPE_BOOLEAN_CLASS: EXITypeClass = 5;
pub const EXITypeClass_VALUE_TYPE_BINARY_CLASS: EXITypeClass = 6;
pub const EXITypeClass_VALUE_TYPE_LIST_CLASS: EXITypeClass = 7;
pub const EXITypeClass_VALUE_TYPE_QNAME_CLASS: EXITypeClass = 8;
pub const EXITypeClass_VALUE_TYPE_INTEGER_CLASS: EXITypeClass = 9;
pub const EXITypeClass_VALUE_TYPE_UNTYPED_CLASS: EXITypeClass = 25;
#[doc = " This is the type of the \"value\" content of EXI events. It is used when schema is available."]
pub type EXITypeClass = ::std::os::raw::c_uint;
#[doc = " Specifies the right-hand side for a production rule.\n The left-hand side is implicitly defined by the\n parent grammar rule."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Production {
    #[doc = " The production content consists of two parts:\n - 8-bits EXI event type, like SD, CH, or EE (most significant 8 bits)\n - 24-bits unique identifier of right-hand side non-terminal (least significant 24 bits)\n Use GET_PROD_EXI_EVENT(), SET_PROD_EXI_EVENT(),"]
    pub content: u32,
    #[doc = " Index of the grammar for the production event, if applicable.\n <ul>\n   <li> AT, CH: index of simple type, in EXIPSchema's simpleTypeTable </li>\n   <li> SE(qname): index of EXI grammar, in EXIPSchema's grammarTable.\n   Processes the content of the SE(qname) event.</li>\n   <li> Otherwise: INDEX_MAX </li>\n </ul>"]
    pub typeId: Index,
    #[doc = " Identifies the terminal portion, the element/attribute for SE(qname),\n SE(uri:*), AT(qname) or AT(uri:*)."]
    pub qnameId: QNameID,
}
#[test]
fn bindgen_test_layout_Production() {
    const UNINIT: ::std::mem::MaybeUninit<Production> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Production>(),
        32usize,
        concat!("Size of: ", stringify!(Production))
    );
    assert_eq!(
        ::std::mem::align_of::<Production>(),
        8usize,
        concat!("Alignment of ", stringify!(Production))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Production),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typeId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Production),
            "::",
            stringify!(typeId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qnameId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Production),
            "::",
            stringify!(qnameId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventCode {
    pub part: [Index; 3usize],
    pub bits: [Index; 3usize],
    pub length: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_EventCode() {
    const UNINIT: ::std::mem::MaybeUninit<EventCode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EventCode>(),
        56usize,
        concat!("Size of: ", stringify!(EventCode))
    );
    assert_eq!(
        ::std::mem::align_of::<EventCode>(),
        8usize,
        concat!("Alignment of ", stringify!(EventCode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).part) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EventCode),
            "::",
            stringify!(part)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EventCode),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(EventCode),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " A container for productions for a particular left-hand side non-terminal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrammarRule {
    #[doc = " Array of grammar productions with event code length 1"]
    pub production: *mut Production,
    #[doc = " The number of productions"]
    pub pCount: Index,
    #[doc = " Meta information for the grammar rule:\n - most significant 15 bits contain the number of AT(qname)[schema-typed value]  productions\n - least significant bit is used to: (1) indicate whether the rule has an EE production\n in case of Schema grammar OR (2) whether the rule contain AT(xsi:type) production in\n case of Build-in element grammar"]
    pub meta: u16,
}
#[test]
fn bindgen_test_layout_GrammarRule() {
    const UNINIT: ::std::mem::MaybeUninit<GrammarRule> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GrammarRule>(),
        24usize,
        concat!("Size of: ", stringify!(GrammarRule))
    );
    assert_eq!(
        ::std::mem::align_of::<GrammarRule>(),
        8usize,
        concat!("Alignment of ", stringify!(GrammarRule))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).production) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrammarRule),
            "::",
            stringify!(production)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrammarRule),
            "::",
            stringify!(pCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrammarRule),
            "::",
            stringify!(meta)
        )
    );
}
#[doc = " Extension to the GrammarRule. In the DynGrammarRule the production array is a dynamic array.\n The dynamic GrammarRule is used for Built-in Element Grammar and Built-in Fragment Grammar"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DynGrammarRule {
    #[doc = " Array of grammar productions with event code length 1"]
    pub production: *mut Production,
    #[doc = " The number of productions"]
    pub pCount: Index,
    #[doc = " Meta information for the grammar rule:\n - most significant 10 bits contain the number of AT(qname)[schema-typed value]  productions\n - least significant 5 bits contain the number of bits for productions event codes"]
    pub meta: u16,
    #[doc = " Additional field"]
    pub prodDim: Index,
}
#[test]
fn bindgen_test_layout_DynGrammarRule() {
    const UNINIT: ::std::mem::MaybeUninit<DynGrammarRule> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DynGrammarRule>(),
        32usize,
        concat!("Size of: ", stringify!(DynGrammarRule))
    );
    assert_eq!(
        ::std::mem::align_of::<DynGrammarRule>(),
        8usize,
        concat!("Alignment of ", stringify!(DynGrammarRule))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).production) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DynGrammarRule),
            "::",
            stringify!(production)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DynGrammarRule),
            "::",
            stringify!(pCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DynGrammarRule),
            "::",
            stringify!(meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prodDim) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DynGrammarRule),
            "::",
            stringify!(prodDim)
        )
    );
}
#[doc = " An EXI regular grammar, organized as a collection of containers for production rules,\n and grouped by each rule's left-hand side non-terminal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXIGrammar {
    #[doc = " Rule container array, where the index of a container is its left-hand side non-terminal ID."]
    pub rule: *mut GrammarRule,
    #[doc = " Bitmap of properties and the value for the grammar contentIndex (the index of the first rule that does not contain attribute content.).\n The most significant 8 bits are the properties and the least significant\n 24 bits is the value for the contentIndex.\n Use parenthesized macro to retrieve, or the \"SET\" form to update.\n <ul>\n   <li> nillable (IS_NILLABLE(p)) </li>\n   <li> built-in grammar (IS_BUILT_IN_ELEM(p)) </li>\n   <li> schema-informed grammar (IS_SCHEMA(p)) </li>\n   <li> does type of this grammar have named sub-types or is it union? (HAS_NAMED_SUB_TYPE_OR_UNION(p)) </li>\n </ul>"]
    pub props: u32,
    #[doc = " Size of the rule array"]
    pub count: SmallIndex,
}
#[test]
fn bindgen_test_layout_EXIGrammar() {
    const UNINIT: ::std::mem::MaybeUninit<EXIGrammar> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EXIGrammar>(),
        24usize,
        concat!("Size of: ", stringify!(EXIGrammar))
    );
    assert_eq!(
        ::std::mem::align_of::<EXIGrammar>(),
        8usize,
        concat!("Alignment of ", stringify!(EXIGrammar))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIGrammar),
            "::",
            stringify!(rule)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).props) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIGrammar),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIGrammar),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " Used for the processing grammar stack."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrammarStackNode {
    pub grammar: *mut EXIGrammar,
    #[doc = " Current (left-hand side) non-terminal ID that identifies the current grammar rule.\n Defines the context/processor state."]
    pub currNonTermID: SmallIndex,
    #[doc = " The qname of the current element being parsed/serialized"]
    pub currQNameID: QNameID,
    pub nextInStack: *mut GrammarStackNode,
}
#[test]
fn bindgen_test_layout_GrammarStackNode() {
    const UNINIT: ::std::mem::MaybeUninit<GrammarStackNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GrammarStackNode>(),
        40usize,
        concat!("Size of: ", stringify!(GrammarStackNode))
    );
    assert_eq!(
        ::std::mem::align_of::<GrammarStackNode>(),
        8usize,
        concat!("Alignment of ", stringify!(GrammarStackNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grammar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrammarStackNode),
            "::",
            stringify!(grammar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currNonTermID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrammarStackNode),
            "::",
            stringify!(currNonTermID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currQNameID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrammarStackNode),
            "::",
            stringify!(currQNameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nextInStack) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GrammarStackNode),
            "::",
            stringify!(nextInStack)
        )
    );
}
#[doc = " Used for the processing grammar stack."]
pub type EXIGrammarStack = GrammarStackNode;
#[doc = " @name String Table Types */\n/**@{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValueEntry {
    pub locValuePartition: ValueEntry__bindgen_ty_1,
    pub valueStr: String,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValueEntry__bindgen_ty_1 {
    pub forQNameId: QNameID,
    pub vxEntryId: Index,
}
#[test]
fn bindgen_test_layout_ValueEntry__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ValueEntry__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ValueEntry__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(ValueEntry__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ValueEntry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ValueEntry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forQNameId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueEntry__bindgen_ty_1),
            "::",
            stringify!(forQNameId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vxEntryId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueEntry__bindgen_ty_1),
            "::",
            stringify!(vxEntryId)
        )
    );
}
#[test]
fn bindgen_test_layout_ValueEntry() {
    const UNINIT: ::std::mem::MaybeUninit<ValueEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ValueEntry>(),
        40usize,
        concat!("Size of: ", stringify!(ValueEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<ValueEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(ValueEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locValuePartition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueEntry),
            "::",
            stringify!(locValuePartition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valueStr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueEntry),
            "::",
            stringify!(valueStr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValueTable {
    pub dynArray: DynArray,
    pub value: *mut ValueEntry,
    pub count: Index,
    #[doc = " Hashtable for fast look-up of global values in the table.\n Only used when:\n serializing &&\n valuePartitionCapacity > 50  &&   //for small table full-scan will work better\n valueMaxLength > 0 // this is essentially equal to valuePartitionCapacity == 0\n"]
    pub hashTbl: *mut hashtable,
    #[doc = " @see http://www.w3.org/TR/2011/REC-exi-20110310/#key-globalID"]
    pub globalId: Index,
}
#[test]
fn bindgen_test_layout_ValueTable() {
    const UNINIT: ::std::mem::MaybeUninit<ValueTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ValueTable>(),
        56usize,
        concat!("Size of: ", stringify!(ValueTable))
    );
    assert_eq!(
        ::std::mem::align_of::<ValueTable>(),
        8usize,
        concat!("Alignment of ", stringify!(ValueTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueTable),
            "::",
            stringify!(dynArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueTable),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueTable),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashTbl) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueTable),
            "::",
            stringify!(hashTbl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).globalId) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueTable),
            "::",
            stringify!(globalId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VxEntry {
    pub globalId: Index,
}
#[test]
fn bindgen_test_layout_VxEntry() {
    const UNINIT: ::std::mem::MaybeUninit<VxEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VxEntry>(),
        8usize,
        concat!("Size of: ", stringify!(VxEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<VxEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(VxEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).globalId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VxEntry),
            "::",
            stringify!(globalId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VxTable {
    pub dynArray: DynArray,
    pub vx: *mut VxEntry,
    pub count: Index,
}
#[test]
fn bindgen_test_layout_VxTable() {
    const UNINIT: ::std::mem::MaybeUninit<VxTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VxTable>(),
        40usize,
        concat!("Size of: ", stringify!(VxTable))
    );
    assert_eq!(
        ::std::mem::align_of::<VxTable>(),
        8usize,
        concat!("Alignment of ", stringify!(VxTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VxTable),
            "::",
            stringify!(dynArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VxTable),
            "::",
            stringify!(vx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VxTable),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PfxTable {
    #[doc = " The number of entries"]
    pub count: SmallIndex,
    pub pfxStr: [String; 4usize],
}
#[test]
fn bindgen_test_layout_PfxTable() {
    const UNINIT: ::std::mem::MaybeUninit<PfxTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PfxTable>(),
        72usize,
        concat!("Size of: ", stringify!(PfxTable))
    );
    assert_eq!(
        ::std::mem::align_of::<PfxTable>(),
        8usize,
        concat!("Alignment of ", stringify!(PfxTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PfxTable),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfxStr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PfxTable),
            "::",
            stringify!(pfxStr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LnEntry {
    pub vxTable: *mut VxTable,
    pub lnStr: String,
    #[doc = " Global element grammar with uriStr:lnStr qname.\n  Either Index of a global element grammar in the SchemaGrammarTable OR\n  INDEX_MAX if a global element grammar with that qname does not exist"]
    pub elemGrammar: Index,
    #[doc = " Global type grammar with uriStr:lnStr qname.\n  Either Index of a global type grammar in the SchemaGrammarTable OR\n  INDEX_MAX if a global type grammar with that qname does not exist"]
    pub typeGrammar: Index,
}
#[test]
fn bindgen_test_layout_LnEntry() {
    const UNINIT: ::std::mem::MaybeUninit<LnEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LnEntry>(),
        40usize,
        concat!("Size of: ", stringify!(LnEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<LnEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(LnEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vxTable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LnEntry),
            "::",
            stringify!(vxTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lnStr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LnEntry),
            "::",
            stringify!(lnStr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elemGrammar) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LnEntry),
            "::",
            stringify!(elemGrammar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typeGrammar) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LnEntry),
            "::",
            stringify!(typeGrammar)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LnTable {
    pub dynArray: DynArray,
    pub ln: *mut LnEntry,
    pub count: Index,
}
#[test]
fn bindgen_test_layout_LnTable() {
    const UNINIT: ::std::mem::MaybeUninit<LnTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LnTable>(),
        40usize,
        concat!("Size of: ", stringify!(LnTable))
    );
    assert_eq!(
        ::std::mem::align_of::<LnTable>(),
        8usize,
        concat!("Alignment of ", stringify!(LnTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LnTable),
            "::",
            stringify!(dynArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ln) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LnTable),
            "::",
            stringify!(ln)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LnTable),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UriEntry {
    pub lnTable: LnTable,
    pub pfxTable: *mut PfxTable,
    pub uriStr: String,
}
#[test]
fn bindgen_test_layout_UriEntry() {
    const UNINIT: ::std::mem::MaybeUninit<UriEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UriEntry>(),
        64usize,
        concat!("Size of: ", stringify!(UriEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<UriEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(UriEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lnTable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UriEntry),
            "::",
            stringify!(lnTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfxTable) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UriEntry),
            "::",
            stringify!(pfxTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uriStr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UriEntry),
            "::",
            stringify!(uriStr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UriTable {
    pub dynArray: DynArray,
    pub uri: *mut UriEntry,
    pub count: SmallIndex,
}
#[test]
fn bindgen_test_layout_UriTable() {
    const UNINIT: ::std::mem::MaybeUninit<UriTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UriTable>(),
        40usize,
        concat!("Size of: ", stringify!(UriTable))
    );
    assert_eq!(
        ::std::mem::align_of::<UriTable>(),
        8usize,
        concat!("Alignment of ", stringify!(UriTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UriTable),
            "::",
            stringify!(dynArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uri) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UriTable),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UriTable),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " Attributes of a schema simple type, including EXI datatype for the simple content."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SimpleType {
    #[doc = " The content of the simple type consists of two parts:\n - 8-bits exiType such as VALUE_TYPE_STRING , VALUE_TYPE_FLOAT, VALUE_TYPE_DECIMAL etc. (most significant 8 bits)\n - 24-bits facetPresenceMask - the least significant 24 bits"]
    pub content: u32,
    #[doc = " either length or (totalDigits and fractionDigits) or typeId, when exiType is LIST (they are mutually exclusive)\n The totalDigits (if available) are encoded in the most significant 16 bits as unsigned integer\n and fractionDigits (if available) are encoded in the least significant 16 bits as unsigned integer"]
    pub length: u32,
    #[doc = " either maxInclusive or maxExclusive or maxLength or\n when exiType is LIST and TYPE_FACET_LENGTH is set then the\n TYPE_FACET_LENGTH of the list as length indicates the\n itemType/typeID of the elements(they are mutually exclusive)"]
    pub max: i64,
    #[doc = " either minInclusive or minExclusive or minLength (they are mutually exclusive)"]
    pub min: i64,
}
#[test]
fn bindgen_test_layout_SimpleType() {
    const UNINIT: ::std::mem::MaybeUninit<SimpleType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SimpleType>(),
        24usize,
        concat!("Size of: ", stringify!(SimpleType))
    );
    assert_eq!(
        ::std::mem::align_of::<SimpleType>(),
        8usize,
        concat!("Alignment of ", stringify!(SimpleType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleType),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleType),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleType),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleType),
            "::",
            stringify!(min)
        )
    );
}
#[doc = " Holds all simple types defined for particular EXI processing (build-in + schema-defined)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SimpleTypeTable {
    pub dynArray: DynArray,
    pub sType: *mut SimpleType,
    pub count: Index,
}
#[test]
fn bindgen_test_layout_SimpleTypeTable() {
    const UNINIT: ::std::mem::MaybeUninit<SimpleTypeTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SimpleTypeTable>(),
        40usize,
        concat!("Size of: ", stringify!(SimpleTypeTable))
    );
    assert_eq!(
        ::std::mem::align_of::<SimpleTypeTable>(),
        8usize,
        concat!("Alignment of ", stringify!(SimpleTypeTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleTypeTable),
            "::",
            stringify!(dynArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleTypeTable),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleTypeTable),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " Holds all EXI grammars defined for particular EXI processing (build-in + schema-defined)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SchemaGrammarTable {
    pub dynArray: DynArray,
    pub grammar: *mut EXIGrammar,
    pub count: Index,
}
#[test]
fn bindgen_test_layout_SchemaGrammarTable() {
    const UNINIT: ::std::mem::MaybeUninit<SchemaGrammarTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SchemaGrammarTable>(),
        40usize,
        concat!("Size of: ", stringify!(SchemaGrammarTable))
    );
    assert_eq!(
        ::std::mem::align_of::<SchemaGrammarTable>(),
        8usize,
        concat!("Alignment of ", stringify!(SchemaGrammarTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SchemaGrammarTable),
            "::",
            stringify!(dynArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grammar) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SchemaGrammarTable),
            "::",
            stringify!(grammar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SchemaGrammarTable),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " Stores the enum values for a particular simple type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct enumDefinition {
    #[doc = " Index of the simple type grammar in the simpleTypeTable"]
    pub typeId: Index,
    #[doc = " Array of enum values"]
    pub values: *mut ::std::os::raw::c_void,
    #[doc = " The number or enum values"]
    pub count: SmallIndex,
}
#[test]
fn bindgen_test_layout_enumDefinition() {
    const UNINIT: ::std::mem::MaybeUninit<enumDefinition> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<enumDefinition>(),
        24usize,
        concat!("Size of: ", stringify!(enumDefinition))
    );
    assert_eq!(
        ::std::mem::align_of::<enumDefinition>(),
        8usize,
        concat!("Alignment of ", stringify!(enumDefinition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typeId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(enumDefinition),
            "::",
            stringify!(typeId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(enumDefinition),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(enumDefinition),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " Stores the enum values for a particular simple type"]
pub type EnumDefinition = enumDefinition;
#[doc = " All the enumerations defined in the schema.\n The entries are sorted by qnameid"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EnumTable {
    pub dynArray: DynArray,
    pub enumDef: *mut EnumDefinition,
    pub count: Index,
}
#[test]
fn bindgen_test_layout_EnumTable() {
    const UNINIT: ::std::mem::MaybeUninit<EnumTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EnumTable>(),
        40usize,
        concat!("Size of: ", stringify!(EnumTable))
    );
    assert_eq!(
        ::std::mem::align_of::<EnumTable>(),
        8usize,
        concat!("Alignment of ", stringify!(EnumTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EnumTable),
            "::",
            stringify!(dynArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumDef) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EnumTable),
            "::",
            stringify!(enumDef)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EnumTable),
            "::",
            stringify!(count)
        )
    );
}
#[doc = " EXIP representation of XML Schema.\n @todo If the simple types are included in the grammarTable's EXIGrammar structure,\n the simpleTypeTable and grammarTable can be merged."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXIPSchema {
    #[doc = " Keep track of allocations within this structure when the\n schema object is dynamically created."]
    pub memList: AllocList,
    #[doc = " Initial string tables"]
    pub uriTable: UriTable,
    #[doc = " The document/fragment grammar for that schema instance."]
    pub docGrammar: EXIGrammar,
    #[doc = " Array of simple types for this schema"]
    pub simpleTypeTable: SimpleTypeTable,
    #[doc = " Array of all the grammars in the schema."]
    pub grammarTable: SchemaGrammarTable,
    #[doc = " The number of schema-informed grammars in grammarTable"]
    pub staticGrCount: Index,
    pub enumTable: EnumTable,
}
#[test]
fn bindgen_test_layout_EXIPSchema() {
    const UNINIT: ::std::mem::MaybeUninit<EXIPSchema> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EXIPSchema>(),
        216usize,
        concat!("Size of: ", stringify!(EXIPSchema))
    );
    assert_eq!(
        ::std::mem::align_of::<EXIPSchema>(),
        8usize,
        concat!("Alignment of ", stringify!(EXIPSchema))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memList) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIPSchema),
            "::",
            stringify!(memList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uriTable) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIPSchema),
            "::",
            stringify!(uriTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).docGrammar) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIPSchema),
            "::",
            stringify!(docGrammar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).simpleTypeTable) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIPSchema),
            "::",
            stringify!(simpleTypeTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grammarTable) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIPSchema),
            "::",
            stringify!(grammarTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).staticGrCount) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIPSchema),
            "::",
            stringify!(staticGrCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumTable) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIPSchema),
            "::",
            stringify!(enumTable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StreamContext {
    #[doc = " Current position in the buffer - bytewise"]
    pub bufferIndx: Index,
    #[doc = " Value between 0 and 7; shows the current position within the current byte.\n 7 is the least significant bit position in the byte."]
    pub bitPointer: ::std::os::raw::c_uchar,
    #[doc = " The qname of the current attribute"]
    pub currAttr: QNameID,
    #[doc = " Non-zero if expecting attribute data or list items"]
    pub expectATData: ::std::os::raw::c_uint,
    #[doc = " TRUE if the current grammar rule must be processed as EmptyType grammar"]
    pub isNilType: boolean,
    #[doc = " Value type of the expected attribute"]
    pub attrTypeId: Index,
}
#[test]
fn bindgen_test_layout_StreamContext() {
    const UNINIT: ::std::mem::MaybeUninit<StreamContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StreamContext>(),
        48usize,
        concat!("Size of: ", stringify!(StreamContext))
    );
    assert_eq!(
        ::std::mem::align_of::<StreamContext>(),
        8usize,
        concat!("Alignment of ", stringify!(StreamContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferIndx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StreamContext),
            "::",
            stringify!(bufferIndx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitPointer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(StreamContext),
            "::",
            stringify!(bitPointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currAttr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(StreamContext),
            "::",
            stringify!(currAttr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expectATData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(StreamContext),
            "::",
            stringify!(expectATData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isNilType) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(StreamContext),
            "::",
            stringify!(isNilType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrTypeId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(StreamContext),
            "::",
            stringify!(attrTypeId)
        )
    );
}
#[doc = " Representation of an Input/Output Stream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ioStream {
    #[doc = " When parsing: A function pointer used to fill the EXI buffer when emptied by reading from \"stream\" \"size\" number of bytes\n When serializing: A function pointer used to write \"size\" number of bytes of the buffer to the stream\n Return the number of bytes read/write"]
    pub readWriteToStream: ::std::option::Option<
        unsafe extern "C" fn(
            buf: *mut ::std::os::raw::c_void,
            size: usize,
            stream: *mut ::std::os::raw::c_void,
        ) -> usize,
    >,
    #[doc = " The input stream to be passed to the readInput function pointer"]
    pub stream: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ioStream() {
    const UNINIT: ::std::mem::MaybeUninit<ioStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ioStream>(),
        16usize,
        concat!("Size of: ", stringify!(ioStream))
    );
    assert_eq!(
        ::std::mem::align_of::<ioStream>(),
        8usize,
        concat!("Alignment of ", stringify!(ioStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readWriteToStream) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ioStream),
            "::",
            stringify!(readWriteToStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ioStream),
            "::",
            stringify!(stream)
        )
    );
}
#[doc = " Representation of an Input/Output Stream"]
pub type IOStream = ioStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DatatypeRepresentationMap {
    pub TODO: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_DatatypeRepresentationMap() {
    const UNINIT: ::std::mem::MaybeUninit<DatatypeRepresentationMap> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DatatypeRepresentationMap>(),
        8usize,
        concat!("Size of: ", stringify!(DatatypeRepresentationMap))
    );
    assert_eq!(
        ::std::mem::align_of::<DatatypeRepresentationMap>(),
        8usize,
        concat!("Alignment of ", stringify!(DatatypeRepresentationMap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TODO) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DatatypeRepresentationMap),
            "::",
            stringify!(TODO)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXIOptions {
    #[doc = " Use the macros GET_ALIGNMENT(p), WITH_COMPRESSION(p), WITH_STRICT,\n WITH_FRAGMENT(p), WITH_SELF_CONTAINED(p) to extract the options:\n alignment, compression, strict, fragment and selfContained\n\n @see options_defs"]
    pub enumOpt: ::std::os::raw::c_uchar,
    #[doc = " Specifies whether comments, pis, etc. are preserved - bit mask of booleans\n Use IS_PRESERVED macro to retrieve the values different preserve options"]
    pub preserve: ::std::os::raw::c_uchar,
    #[doc = " schemaID mode, default SCHEMA_ID_ABSENT"]
    pub schemaIDMode: SchemaIdMode,
    #[doc = " Identify the schema information, if any, used to encode the body.\n It the schemaID field is absent or empty, then schemaID is\n an empty string. Use schemaIDMode to check/set the exact schemaID mode\n of operation"]
    pub schemaID: String,
    #[doc = " Specify alternate datatype representations for typed values in the EXI body"]
    pub drMap: *mut DatatypeRepresentationMap,
    #[doc = "  Specifies the block size used for EXI compression"]
    pub blockSize: u32,
    #[doc = " Specifies the maximum string length of value content items to be considered for addition to the string table.\n INDEX_MAX - unbounded"]
    pub valueMaxLength: Index,
    #[doc = " Specifies the total capacity of value partitions in a string table\n INDEX_MAX - unbounded"]
    pub valuePartitionCapacity: Index,
    #[doc = " User defined meta-data may be added"]
    pub user_defined_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_EXIOptions() {
    const UNINIT: ::std::mem::MaybeUninit<EXIOptions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EXIOptions>(),
        64usize,
        concat!("Size of: ", stringify!(EXIOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<EXIOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(EXIOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumOpt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIOptions),
            "::",
            stringify!(enumOpt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preserve) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIOptions),
            "::",
            stringify!(preserve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).schemaIDMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIOptions),
            "::",
            stringify!(schemaIDMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).schemaID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIOptions),
            "::",
            stringify!(schemaID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drMap) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIOptions),
            "::",
            stringify!(drMap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIOptions),
            "::",
            stringify!(blockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valueMaxLength) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIOptions),
            "::",
            stringify!(valueMaxLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valuePartitionCapacity) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIOptions),
            "::",
            stringify!(valuePartitionCapacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_defined_data) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIOptions),
            "::",
            stringify!(user_defined_data)
        )
    );
}
#[doc = " Represents an EXI header"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXIheader {
    #[doc = " Boolean value - FALSE for lack of EXI cookie, otherwise TRUE"]
    pub has_cookie: boolean,
    #[doc = " Boolean value - FALSE for lack of EXI Options, otherwise TRUE"]
    pub has_options: boolean,
    #[doc = " Boolean value - TRUE preview version, FALSE final version"]
    pub is_preview_version: boolean,
    #[doc = " EXI stream version"]
    pub version_number: i16,
    pub opts: EXIOptions,
}
#[test]
fn bindgen_test_layout_EXIheader() {
    const UNINIT: ::std::mem::MaybeUninit<EXIheader> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EXIheader>(),
        80usize,
        concat!("Size of: ", stringify!(EXIheader))
    );
    assert_eq!(
        ::std::mem::align_of::<EXIheader>(),
        8usize,
        concat!("Alignment of ", stringify!(EXIheader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_cookie) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIheader),
            "::",
            stringify!(has_cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_options) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIheader),
            "::",
            stringify!(has_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_preview_version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIheader),
            "::",
            stringify!(is_preview_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_number) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIheader),
            "::",
            stringify!(version_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIheader),
            "::",
            stringify!(opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BinaryBuffer {
    #[doc = " Read/write memory buffer"]
    pub buf: *mut ::std::os::raw::c_char,
    #[doc = " The size of the buffer"]
    pub bufLen: Index,
    #[doc = " The size of the data stored in the buffer - number of bytes.\n When parsing, this is the EXI data in the buffer available for parsing.\n When serializing, this is the size of the EXI data encoded in the buffer\n which is set during the call to serialize.endDocument();"]
    pub bufContent: Index,
    #[doc = " Input/Output Stream used to fill/flush the buffer during processing"]
    pub ioStrm: IOStream,
}
#[test]
fn bindgen_test_layout_BinaryBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<BinaryBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BinaryBuffer>(),
        40usize,
        concat!("Size of: ", stringify!(BinaryBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<BinaryBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(BinaryBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryBuffer),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufLen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryBuffer),
            "::",
            stringify!(bufLen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufContent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryBuffer),
            "::",
            stringify!(bufContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ioStrm) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BinaryBuffer),
            "::",
            stringify!(ioStrm)
        )
    );
}
#[doc = " Represents an EXI stream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXIStream {
    pub buffer: BinaryBuffer,
    #[doc = " EXI Header - the most important field is the EXI Options. They control the\n parsing and serialization of the stream."]
    pub header: EXIheader,
    #[doc = " Holds the current state of the stream."]
    pub context: StreamContext,
    #[doc = " The value string table"]
    pub valueTable: ValueTable,
    #[doc = " The grammar stack used during processing"]
    pub gStack: *mut EXIGrammarStack,
    #[doc = " Stores the information of all the allocated memory for that stream,\n except the global sting values that are stored in the ValueTable"]
    pub memList: AllocList,
    #[doc = " Schema information for that stream.\n It contains the string tables and possibly schema-informed EXI grammars."]
    pub schema: *mut EXIPSchema,
}
#[test]
fn bindgen_test_layout_EXIStream() {
    const UNINIT: ::std::mem::MaybeUninit<EXIStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EXIStream>(),
        264usize,
        concat!("Size of: ", stringify!(EXIStream))
    );
    assert_eq!(
        ::std::mem::align_of::<EXIStream>(),
        8usize,
        concat!("Alignment of ", stringify!(EXIStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIStream),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIStream),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIStream),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valueTable) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIStream),
            "::",
            stringify!(valueTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gStack) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIStream),
            "::",
            stringify!(gStack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memList) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIStream),
            "::",
            stringify!(memList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).schema) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIStream),
            "::",
            stringify!(schema)
        )
    );
}
extern "C" {
    #[doc = " @brief Set the EXI options to their default values\n\n @param[in, out] opts EXI options structure"]
    pub fn makeDefaultOpts(opts: *mut EXIOptions);
}
extern "C" {
    #[doc = " @brief Check if the EXI options are set correctly\n\n @param[in] opts EXI options structure\n @returns EXIP_OK if the values are correct, otherwise EXIP_HEADER_OPTIONS_MISMATCH"]
    pub fn checkOptionValues(opts: *mut EXIOptions) -> errorCode;
}
extern "C" {
    pub fn pushOnStack(
        stack: *mut *mut GenericStack,
        item: *mut ::std::os::raw::c_void,
    ) -> errorCode;
}
extern "C" {
    pub fn popFromStack(stack: *mut *mut GenericStack, item: *mut *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn compareEnumDefs(
        enum1: *const ::std::os::raw::c_void,
        enum2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Simple container for function pointers for document events."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ContentHandler {
    pub startDocument: ::std::option::Option<
        unsafe extern "C" fn(app_data: *mut ::std::os::raw::c_void) -> errorCode,
    >,
    pub endDocument: ::std::option::Option<
        unsafe extern "C" fn(app_data: *mut ::std::os::raw::c_void) -> errorCode,
    >,
    pub startElement: ::std::option::Option<
        unsafe extern "C" fn(qname: QName, app_data: *mut ::std::os::raw::c_void) -> errorCode,
    >,
    pub endElement: ::std::option::Option<
        unsafe extern "C" fn(app_data: *mut ::std::os::raw::c_void) -> errorCode,
    >,
    pub attribute: ::std::option::Option<
        unsafe extern "C" fn(qname: QName, app_data: *mut ::std::os::raw::c_void) -> errorCode,
    >,
    pub intData: ::std::option::Option<
        unsafe extern "C" fn(int_val: Integer, app_data: *mut ::std::os::raw::c_void) -> errorCode,
    >,
    pub booleanData: ::std::option::Option<
        unsafe extern "C" fn(bool_val: boolean, app_data: *mut ::std::os::raw::c_void) -> errorCode,
    >,
    pub stringData: ::std::option::Option<
        unsafe extern "C" fn(str_val: String, app_data: *mut ::std::os::raw::c_void) -> errorCode,
    >,
    pub floatData: ::std::option::Option<
        unsafe extern "C" fn(float_val: Float, app_data: *mut ::std::os::raw::c_void) -> errorCode,
    >,
    pub binaryData: ::std::option::Option<
        unsafe extern "C" fn(
            binary_val: *const ::std::os::raw::c_char,
            nbytes: Index,
            app_data: *mut ::std::os::raw::c_void,
        ) -> errorCode,
    >,
    pub dateTimeData: ::std::option::Option<
        unsafe extern "C" fn(
            dt_val: EXIPDateTime,
            app_data: *mut ::std::os::raw::c_void,
        ) -> errorCode,
    >,
    pub decimalData: ::std::option::Option<
        unsafe extern "C" fn(dec_val: Decimal, app_data: *mut ::std::os::raw::c_void) -> errorCode,
    >,
    pub listData: ::std::option::Option<
        unsafe extern "C" fn(
            exiType: EXITypeClass,
            itemCount: ::std::os::raw::c_uint,
            app_data: *mut ::std::os::raw::c_void,
        ) -> errorCode,
    >,
    pub qnameData: ::std::option::Option<
        unsafe extern "C" fn(qname: QName, app_data: *mut ::std::os::raw::c_void) -> errorCode,
    >,
    pub processingInstruction: ::std::option::Option<
        unsafe extern "C" fn(app_data: *mut ::std::os::raw::c_void) -> errorCode,
    >,
    pub namespaceDeclaration: ::std::option::Option<
        unsafe extern "C" fn(
            ns: String,
            prefix: String,
            isLocalElementNS: boolean,
            app_data: *mut ::std::os::raw::c_void,
        ) -> errorCode,
    >,
    pub warning: ::std::option::Option<
        unsafe extern "C" fn(
            code: errorCode,
            msg: *const ::std::os::raw::c_char,
            app_data: *mut ::std::os::raw::c_void,
        ) -> errorCode,
    >,
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            code: errorCode,
            msg: *const ::std::os::raw::c_char,
            app_data: *mut ::std::os::raw::c_void,
        ) -> errorCode,
    >,
    pub fatalError: ::std::option::Option<
        unsafe extern "C" fn(
            code: errorCode,
            msg: *const ::std::os::raw::c_char,
            app_data: *mut ::std::os::raw::c_void,
        ) -> errorCode,
    >,
    pub selfContained: ::std::option::Option<
        unsafe extern "C" fn(app_data: *mut ::std::os::raw::c_void) -> errorCode,
    >,
}
#[test]
fn bindgen_test_layout_ContentHandler() {
    const UNINIT: ::std::mem::MaybeUninit<ContentHandler> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ContentHandler>(),
        160usize,
        concat!("Size of: ", stringify!(ContentHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<ContentHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(ContentHandler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startDocument) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(startDocument)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endDocument) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(endDocument)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startElement) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(startElement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endElement) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(endElement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attribute) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(intData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).booleanData) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(booleanData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stringData) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(stringData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).floatData) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(floatData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binaryData) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(binaryData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dateTimeData) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(dateTimeData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decimalData) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(decimalData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listData) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(listData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qnameData) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(qnameData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processingInstruction) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(processingInstruction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).namespaceDeclaration) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(namespaceDeclaration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).warning) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(warning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fatalError) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(fatalError)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selfContained) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ContentHandler),
            "::",
            stringify!(selfContained)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize the content handler before use\n @param[in] handler fresh ContentHandler\n"]
    pub fn initContentHandler(handler: *mut ContentHandler);
}
#[doc = " Parses an EXI document."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Parser {
    #[doc = " Stream containing the EXI document for parsing."]
    pub strm: EXIStream,
    #[doc = " Function pointers for document events."]
    pub handler: ContentHandler,
    pub app_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Parser() {
    const UNINIT: ::std::mem::MaybeUninit<Parser> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Parser>(),
        432usize,
        concat!("Size of: ", stringify!(Parser))
    );
    assert_eq!(
        ::std::mem::align_of::<Parser>(),
        8usize,
        concat!("Alignment of ", stringify!(Parser))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Parser),
            "::",
            stringify!(strm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(Parser),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_data) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(Parser),
            "::",
            stringify!(app_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXIParser {
    pub initParser: ::std::option::Option<
        unsafe extern "C" fn(
            parser: *mut Parser,
            buffer: BinaryBuffer,
            app_data: *mut ::std::os::raw::c_void,
        ) -> errorCode,
    >,
    pub parseHeader: ::std::option::Option<
        unsafe extern "C" fn(parser: *mut Parser, outOfBandOpts: boolean) -> errorCode,
    >,
    pub setSchema: ::std::option::Option<
        unsafe extern "C" fn(parser: *mut Parser, schema: *mut EXIPSchema) -> errorCode,
    >,
    pub parseNext: ::std::option::Option<unsafe extern "C" fn(parser: *mut Parser) -> errorCode>,
    pub pushEXIData: ::std::option::Option<
        unsafe extern "C" fn(
            inBuf: *mut ::std::os::raw::c_char,
            bufSize: ::std::os::raw::c_uint,
            parser: *mut Parser,
        ) -> errorCode,
    >,
    pub destroyParser: ::std::option::Option<unsafe extern "C" fn(parser: *mut Parser)>,
}
#[test]
fn bindgen_test_layout_EXIParser() {
    const UNINIT: ::std::mem::MaybeUninit<EXIParser> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EXIParser>(),
        48usize,
        concat!("Size of: ", stringify!(EXIParser))
    );
    assert_eq!(
        ::std::mem::align_of::<EXIParser>(),
        8usize,
        concat!("Alignment of ", stringify!(EXIParser))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initParser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIParser),
            "::",
            stringify!(initParser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parseHeader) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIParser),
            "::",
            stringify!(parseHeader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setSchema) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIParser),
            "::",
            stringify!(setSchema)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parseNext) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIParser),
            "::",
            stringify!(parseNext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pushEXIData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIParser),
            "::",
            stringify!(pushEXIData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroyParser) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(EXIParser),
            "::",
            stringify!(destroyParser)
        )
    );
}
extern "C" {
    #[doc = " Used during parsing for easy access to the\n EXIP parsing API"]
    pub static parse: EXIParser;
}
extern "C" {
    #[doc = " @brief Initialize a parser object\n @param[out] parser the parser object\n @param[in] buffer an input buffer holding (part of) the representation of EXI stream\n @param[in] app_data Application data to be passed to the content handler callbacks\n @return Error handling code"]
    pub fn initParser(
        parser: *mut Parser,
        buffer: BinaryBuffer,
        app_data: *mut ::std::os::raw::c_void,
    ) -> errorCode;
}
extern "C" {
    #[doc = " @brief Parse the header on the EXI stream contained in the parser object\n @param[in] parser the parser object\n @param[in] outOfBandOpts TRUE if there are out-of-band options set in parser->strm.header\n FALSE otherwise\n @return Error handling code"]
    pub fn parseHeader(parser: *mut Parser, outOfBandOpts: boolean) -> errorCode;
}
extern "C" {
    #[doc = " @brief Initialize the schema information to be used for parsing\n @param[in] parser the parser object\n @param[in] schema object; if parser.strm.header.opts.schemaIDMode == SCHEMA_ID_NIL or\n parser.strm.header.opts.schemaIDMode == SCHEMA_ID_EMPTY the schema object is ignored;\n if parser.strm.header.opts.schemaIDMode == SCHEMA_ID_ABSENT and schema == NULL then\n schema-less mode, schema != NULL schema enabled;\n if parser.strm.header.opts.schemaIDMode == SCHEMA_ID_SET and schema == NULL is an error\n parser.strm.header.opts.schemaID contains the identifier of the schema if any\n\n @return Error handling code"]
    pub fn setSchema(parser: *mut Parser, schema: *mut EXIPSchema) -> errorCode;
}
extern "C" {
    #[doc = " @brief Parse the next content item from the EXI stream contained in the parser object\n\n @param[in] parser the parser object\n\n @return Error handling code; EXIP_PARSING_COMPLETE when the parsing is completed succesfully,\n EXIP_BUFFER_END_REACHED when the whole content of the buffer is parsed but there is more\n events in the EXI stream. In case of EXIP_BUFFER_END_REACHED, pushEXIData() must be used\n to fill the buffer with the next chunk of the EXI stream before calling parseNext() again."]
    pub fn parseNext(parser: *mut Parser) -> errorCode;
}
extern "C" {
    #[doc = " @brief Pushes more data to the parsing buffer to parse\n\n This function is used to implement push-parsing interface.\n After parseNext() returns EXIP_BUFFER_END_REACHED use this\n function to add more data to the parsing buffer.\n\n @warning Padding bits to fill a byte when in bit-packed mode\n should not be used as they will be interpreted as if being part\n of the EXI stream. This can be a concern when streaming EXI\n data which is not byte-aligned.\n\n @param[in] inBuf the next EXI stream chunk to be parsed\n @param[in] bufSize the size in bytes of the inBuf\n @param[in] parser the parser object\n\n @return Error handling code"]
    pub fn pushEXIData(
        inBuf: *mut ::std::os::raw::c_char,
        bufSize: ::std::os::raw::c_uint,
        parser: *mut Parser,
    ) -> errorCode;
}
extern "C" {
    #[doc = " @brief Free any memroy allocated by parser object\n @param[in] parser the parser object"]
    pub fn destroyParser(parser: *mut Parser);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXISerializer {
    pub startDocument:
        ::std::option::Option<unsafe extern "C" fn(strm: *mut EXIStream) -> errorCode>,
    pub endDocument: ::std::option::Option<unsafe extern "C" fn(strm: *mut EXIStream) -> errorCode>,
    pub startElement: ::std::option::Option<
        unsafe extern "C" fn(
            strm: *mut EXIStream,
            qname: QName,
            valueType: *mut EXITypeClass,
        ) -> errorCode,
    >,
    pub endElement: ::std::option::Option<unsafe extern "C" fn(strm: *mut EXIStream) -> errorCode>,
    pub attribute: ::std::option::Option<
        unsafe extern "C" fn(
            strm: *mut EXIStream,
            qname: QName,
            isSchemaType: boolean,
            valueType: *mut EXITypeClass,
        ) -> errorCode,
    >,
    pub intData: ::std::option::Option<
        unsafe extern "C" fn(strm: *mut EXIStream, int_val: Integer) -> errorCode,
    >,
    pub booleanData: ::std::option::Option<
        unsafe extern "C" fn(strm: *mut EXIStream, bool_val: boolean) -> errorCode,
    >,
    pub stringData: ::std::option::Option<
        unsafe extern "C" fn(strm: *mut EXIStream, str_val: String) -> errorCode,
    >,
    pub floatData: ::std::option::Option<
        unsafe extern "C" fn(strm: *mut EXIStream, float_val: Float) -> errorCode,
    >,
    pub binaryData: ::std::option::Option<
        unsafe extern "C" fn(
            strm: *mut EXIStream,
            binary_val: *const ::std::os::raw::c_char,
            nbytes: Index,
        ) -> errorCode,
    >,
    pub dateTimeData: ::std::option::Option<
        unsafe extern "C" fn(strm: *mut EXIStream, dt_val: EXIPDateTime) -> errorCode,
    >,
    pub decimalData: ::std::option::Option<
        unsafe extern "C" fn(strm: *mut EXIStream, dec_val: Decimal) -> errorCode,
    >,
    pub listData: ::std::option::Option<
        unsafe extern "C" fn(strm: *mut EXIStream, itemCount: ::std::os::raw::c_uint) -> errorCode,
    >,
    pub qnameData: ::std::option::Option<
        unsafe extern "C" fn(strm: *mut EXIStream, qname: QName) -> errorCode,
    >,
    pub processingInstruction:
        ::std::option::Option<unsafe extern "C" fn(strm: *mut EXIStream) -> errorCode>,
    pub namespaceDeclaration: ::std::option::Option<
        unsafe extern "C" fn(
            strm: *mut EXIStream,
            ns: String,
            prefix: String,
            isLocalElementNS: boolean,
        ) -> errorCode,
    >,
    pub exiHeader: ::std::option::Option<unsafe extern "C" fn(strm: *mut EXIStream) -> errorCode>,
    pub selfContained:
        ::std::option::Option<unsafe extern "C" fn(strm: *mut EXIStream) -> errorCode>,
    pub initHeader: ::std::option::Option<unsafe extern "C" fn(strm: *mut EXIStream)>,
    pub initStream: ::std::option::Option<
        unsafe extern "C" fn(
            strm: *mut EXIStream,
            buffer: BinaryBuffer,
            schema: *mut EXIPSchema,
        ) -> errorCode,
    >,
    pub closeEXIStream:
        ::std::option::Option<unsafe extern "C" fn(strm: *mut EXIStream) -> errorCode>,
    pub flushEXIData:
        ::std::option::Option<unsafe extern "C" fn(strm: *mut EXIStream) -> errorCode>,
}
#[test]
fn bindgen_test_layout_EXISerializer() {
    const UNINIT: ::std::mem::MaybeUninit<EXISerializer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EXISerializer>(),
        176usize,
        concat!("Size of: ", stringify!(EXISerializer))
    );
    assert_eq!(
        ::std::mem::align_of::<EXISerializer>(),
        8usize,
        concat!("Alignment of ", stringify!(EXISerializer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startDocument) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(startDocument)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endDocument) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(endDocument)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startElement) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(startElement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endElement) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(endElement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attribute) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(intData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).booleanData) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(booleanData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stringData) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(stringData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).floatData) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(floatData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binaryData) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(binaryData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dateTimeData) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(dateTimeData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decimalData) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(decimalData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listData) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(listData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qnameData) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(qnameData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processingInstruction) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(processingInstruction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).namespaceDeclaration) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(namespaceDeclaration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exiHeader) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(exiHeader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selfContained) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(selfContained)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initHeader) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(initHeader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initStream) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(initStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closeEXIStream) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(closeEXIStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flushEXIData) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(EXISerializer),
            "::",
            stringify!(flushEXIData)
        )
    );
}
extern "C" {
    #[doc = " Used during serialization for easy access to the\n EXIP serialization API"]
    pub static serialize: EXISerializer;
}
extern "C" {
    #[doc = " @brief Indicates the start of the EXI body serialization\n\n @param[in, out] strm EXI stream object\n @return Error handling code"]
    pub fn startDocument(strm: *mut EXIStream) -> errorCode;
}
extern "C" {
    #[doc = " @brief Indicates the end of the EXI body serialization\n\n @param[in, out] strm EXI stream object\n @return Error handling code"]
    pub fn endDocument(strm: *mut EXIStream) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encodes start of an element with qualified name qname\n\n @param[in, out] strm EXI stream object\n @param[in] qname qualified name of the element\n @param[out] valueType In case of a simple type element - the EXI type class\n of the element. It should be used to determine which function for data handling\n to be used for its content. If complex type - VALUE_TYPE_NONE_CLASS\n @return Error handling code"]
    pub fn startElement(
        strm: *mut EXIStream,
        qname: QName,
        valueType: *mut EXITypeClass,
    ) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encodes the end of the last element\n\n @param[in, out] strm EXI stream object\n @return Error handling code"]
    pub fn endElement(strm: *mut EXIStream) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encodes a start of an attribute with qualified name qname\n Note that the attributes within an element must be encoded lexicographically sorted\n when in schema mode. Sorting is done first by local name and then by namespace.\n\n @param[in, out] strm EXI stream object\n @param[in] qname qualified name of the attribute\n @param[in] isSchemaType for schema mode, define if the value of the\n attribute is conforming to the type defined in the schema for that attribute. If in schemaless it should be TRUE;\n @param[out] valueType In case of a schema mode and isSchemaType == TRUE - the EXI type class\n of the attribute. It should be used to determine which function for data handling\n to be used for its content. Otherwise - VALUE_TYPE_NONE_CLASS\n @return Error handling code\n @todo Consider handling the lexicographical sorting of attributes by exip encoding utilities?"]
    pub fn attribute(
        strm: *mut EXIStream,
        qname: QName,
        isSchemaType: boolean,
        valueType: *mut EXITypeClass,
    ) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encodes integer data for element or attribute\n\n @param[in, out] strm EXI stream object\n @param[in] int_val value to be encoded\n @return Error handling code\n @note Use in schema mode only!"]
    pub fn intData(strm: *mut EXIStream, int_val: Integer) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encodes boolean data for element or attribute\n\n @param[in, out] strm EXI stream object\n @param[in] bool_val value to be encoded\n @return Error handling code\n @note Use in schema mode only!"]
    pub fn booleanData(strm: *mut EXIStream, bool_val: boolean) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encodes string data for element or attribute\n\n @param[in, out] strm EXI stream object\n @param[in] str_val value to be encoded\n @return Error handling code"]
    pub fn stringData(strm: *mut EXIStream, str_val: String) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encodes float data for element or attribute\n\n @param[in, out] strm EXI stream object\n @param[in] float_val value to be encoded\n @return Error handling code\n @note Use in schema mode only!"]
    pub fn floatData(strm: *mut EXIStream, float_val: Float) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encodes binary data for element or attribute\n\n @param[in, out] strm EXI stream object\n @param[in] binary_val value to be encoded\n @param[in] nbytes number of bytes in binary_val\n @return Error handling code\n @note Use in schema mode only!"]
    pub fn binaryData(
        strm: *mut EXIStream,
        binary_val: *const ::std::os::raw::c_char,
        nbytes: Index,
    ) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encodes dateTime data for element or attribute\n\n @param[in, out] strm EXI stream object\n @param[in] dt_val value to be encoded\n @return Error handling code\n @note Use in schema mode only!"]
    pub fn dateTimeData(strm: *mut EXIStream, dt_val: EXIPDateTime) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encodes decimal data for element or attribute\n\n @param[in, out] strm EXI stream object\n @param[in] dec_val value to be encoded\n @return Error handling code\n @note Use in schema mode only!"]
    pub fn decimalData(strm: *mut EXIStream, dec_val: Decimal) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encodes list data for element or attribute\n\n @param[in, out] strm EXI stream object\n @param[in] itemCount the number of list items to be encoded\n @return Error handling code\n @note Use in schema mode only!"]
    pub fn listData(strm: *mut EXIStream, itemCount: ::std::os::raw::c_uint) -> errorCode;
}
extern "C" {
    #[doc = " @brief This function is only used to encode the value of xsi:type attribute\n\n @param[in, out] strm EXI stream object\n @param[in] qname the qname to be encoded\n @return Error handling code"]
    pub fn qnameData(strm: *mut EXIStream, qname: QName) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encode a processing instruction\n\n @param[in, out] strm EXI stream object\n @return Error handling code\n @todo define the parameters!"]
    pub fn processingInstruction(strm: *mut EXIStream) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encode a namespace declaration when Preserve.prefixes == TRUE\n\n @param[in, out] strm EXI stream object\n @param[in] ns the namespace to be encoded\n @param[in] prefix the prefix of the namespace to be encoded\n @param[in] isLocalElementNS TRUE if this is the namespace locally defined for the element\n that contains it (see local-element-ns flag in the EXI spec)\n @return Error handling code"]
    pub fn namespaceDeclaration(
        strm: *mut EXIStream,
        ns: String,
        prefix: String,
        isLocalElementNS: boolean,
    ) -> errorCode;
}
extern "C" {
    #[doc = " @brief Encode a self Contained event used for indexing independent elements for random access\n\n @param[in, out] strm EXI stream object\n @return Error handling code\n @todo define the parameters!"]
    pub fn selfContained(strm: *mut EXIStream) -> errorCode;
}
extern "C" {
    #[doc = " @brief Initialize the header of an EXI stream object\n\n @param[in, out] strm EXI stream object\n @return Error handling code"]
    pub fn initHeader(strm: *mut EXIStream);
}
extern "C" {
    #[doc = " @brief Initialize EXI stream object\n\n @param[in, out] strm EXI stream\n @param[in, out] buffer output buffer for storing the encoded EXI stream\n @param[in] schema a compiled schema information to be used for schema enabled processing, NULL if no schema is available\n @return Error handling code"]
    pub fn initStream(
        strm: *mut EXIStream,
        buffer: BinaryBuffer,
        schema: *mut EXIPSchema,
    ) -> errorCode;
}
extern "C" {
    #[doc = " @brief Destroy an EXI stream object releasing all the allocated memory for it\n\n @param[in, out] strm EXI stream object\n @return Error handling code"]
    pub fn closeEXIStream(strm: *mut EXIStream) -> errorCode;
}
extern "C" {
    #[doc = " @brief In case the EXI buffer (strm->buffer) is filled this function can be used to\n flush it to some external buffer when strm->buffer.ioStrm.readWriteToStream is not available.\n This is useful when streaming EXI data, for example, which needs to be implemented\n without a blocking call to the flushing interface i.e. strm->buffer.ioStrm.readWriteToStream.\n\n @warning Padding bits to fill a byte when in bit-packed mode\n should not be used as they will be interpreted as if being part\n of the EXI stream. This function always flushes the EXI buffer\n to the last byte boundary thus making sure the padding is not needed.\n\n @remark The proper use of this function is as follows:\n When building the EXI body, before each call to serialize.*() functions\n the context of the EXI stream needs to be saved to a vairable e.g.,\n StreamContext savedContext = parser->strm.context;\n if the serialize.*() returns EXIP_BUFFER_END_REACHED the state needs to\n be restored with: parser->strm.context = savedContext;\n Then the flushEXIData() function must be called to flush the\n buffer after which the failed serialize.*() call needs to be repeated.\n\n @param[in, out] strm EXI stream object\n @param[out] outBuf the next EXI stream chunk to be parsed\n @param[in] bufSize the size in bytes of the inBuf\n @param[out] bytesFlush bytes written to the outBuf\n @return Error handling code"]
    pub fn flushEXIData(
        strm: *mut EXIStream,
        outBuf: *mut ::std::os::raw::c_char,
        bufSize: ::std::os::raw::c_uint,
        bytesFlush: *mut ::std::os::raw::c_uint,
    ) -> errorCode;
}
extern "C" {
    #[doc = " To be used by code generation tools such as static XML bindings\n and when efficiency is of high importance\n\n @param[in, out] strm EXI stream\n @param[in] ec EXI event code of the production\n @param[in] qname used only for SE(*), AT(*), SE(uri:*), AT(uri:*) and when\n a new prefix should be serialized in SE(QName) and AT(QName); NULL otherwise\n @return Error handling code"]
    pub fn serializeEvent(strm: *mut EXIStream, ec: EventCode, qname: *mut QName) -> errorCode;
}
pub const SchemaFormat_SCHEMA_FORMAT_XSD_EXI: SchemaFormat = 0;
pub const SchemaFormat_SCHEMA_FORMAT_XSD_XML: SchemaFormat = 1;
pub const SchemaFormat_SCHEMA_FORMAT_DTD: SchemaFormat = 2;
pub const SchemaFormat_SCHEMA_FORMAT_RELAX_NG: SchemaFormat = 3;
#[doc = " @name Supported schema formats\n Such as XML-XSD, EXI-XSD, DTD or any other schema representation"]
pub type SchemaFormat = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Call-back handler, to be implemented by the applications\n It is called to resolve references to schemas (<include> and <import>)\n not included in the BinaryBuffer list of generateSchemaInformedGrammars().\n\n @param[in] namespace NULL for <include> reference; the target namespace of <import>-ed schema otherwise\n @param[in] schemaLocation can be NULL for <import> reference only; The uri location of the schema otherwise\n @param[out] buffers an array of input buffers holding the representation of the schema <include>-ed or <import>-ed\n             Each buffer refers to one schema file.\n @param[out] bufCount the number of buffers in the array\n @param[out] schemaFormat EXI, XSD, DTD or any other schema representation supported\n @param[out] opt options used for EXI schemaFormat - otherwise NULL. If options are set then they will be used\n for processing the EXI XSD stream although no options are specified in the EXI header. If there are\n options defined in the EXI header of the XSD stream then this parameter must be NULL.\n @return Error handling code\n\n @note In the case of <include> - both the host- and included-schema must have identical target namespace.\n That is, the current implementation does not support the case of using <include> from XML Schema\n that has non empty target namespace and the referenced/included XML schema have an empty target\n namespace, although this is allowed by the XML Schema spec."]
    pub fn loadSchemaHandler(
        namespace: *mut String,
        schemaLocation: *mut String,
        buffers: *mut *mut BinaryBuffer,
        bufCount: *mut ::std::os::raw::c_uint,
        schemaFormat: *mut SchemaFormat,
        opt: *mut *mut EXIOptions,
    ) -> errorCode;
}
extern "C" {
    #[doc = " @brief Given a set of XML schemes, generates all Schema-informed Element and Type Grammars\n as well as the pre-populated string tables (i.e. EXIPSchema instance)\n The current version supports only SCHEMA_FORMAT_XSD_EXI format of the XML schema.\n\n @param[in] buffers an array of input buffers holding the representation of the schema.\n \t\t\t  Each buffer refers to one schema file.\n @param[in] bufCount the number of buffers in the array\n @param[in] schemaFormat EXI, XSD, DTD or any other schema representation supported\n @param[in] opt options used for EXI schemaFormat - otherwise NULL. If options are set then they will be used\n for processing the EXI XSD stream although no options are specified in the EXI header. If there are\n options defined in the EXI header of the XSD stream then this parameter must be NULL.\n @param[out] schema the resulted schema information used for processing EXI streams\n @param[in] loadSchemaHandler Call-back handler for loading <include>-ed or <import>-ed schema files; Can be left NULL\n if no <include> or <import> statements are used in the XML schema.\n @return Error handling code\n\n @note In the case of <include> - both the host- and included-schema must have identical target namespace.\n That is, the current implementation does not support the case of using <include> from XML Schema\n that has non empty target namespace and the referenced/included XML schema have an empty target\n namespace, although this is allowed by the XML Schema spec."]
    pub fn generateSchemaInformedGrammars(
        buffers: *mut BinaryBuffer,
        bufCount: ::std::os::raw::c_uint,
        schemaFormat: SchemaFormat,
        opt: *mut EXIOptions,
        schema: *mut EXIPSchema,
        loadSchemaHandler: ::std::option::Option<
            unsafe extern "C" fn(
                namespace: *mut String,
                schemaLocation: *mut String,
                buffers: *mut *mut BinaryBuffer,
                bufCount: *mut ::std::os::raw::c_uint,
                schemaFormat: *mut SchemaFormat,
                opt: *mut *mut EXIOptions,
            ) -> errorCode,
        >,
    ) -> errorCode;
}
extern "C" {
    #[doc = " @brief Frees all the memory allocated by an EXIPSchema object\n @param[in] schema the schema containing the EXI grammars to be freed"]
    pub fn destroySchema(schema: *mut EXIPSchema);
}
extern "C" {
    #[doc = " @brief Allocate a memory for a string with UCSchars number of UCS characters\n It depends on the representation of the characters\n\n @param[in, out] str a pointer to the uninitialized string\n @param[in] UCSchars the number of characters (as described by UCS [ISO/IEC 10646])\n @return Error handling code"]
    pub fn allocateStringMemory(str_: *mut *mut CharType, UCSchars: Index) -> errorCode;
}
extern "C" {
    #[doc = " @brief Allocate a memory for a string with UCSchars number of UCS characters\n It depends on the representation of the characters\n\n @param[in, out] str a pointer to the uninitialized string\n @param[in] UCSchars the number of characters (as described by UCS [ISO/IEC 10646])\n @param[in, out] memList A list storing the memory allocations\n @return Error handling code"]
    pub fn allocateStringMemoryManaged(
        str_: *mut *mut CharType,
        UCSchars: Index,
        memList: *mut AllocList,
    ) -> errorCode;
}
extern "C" {
    #[doc = " @brief Writes a UCS [ISO/IEC 10646] code point to a string\n It depends on the representation of the characters.\n The memory needed for str should be allocated before the invocation\n of this function\n\n @param[in, out] str string to be written on\n @param[in] code_point UCS [ISO/IEC 10646] code point\n @param[in, out] writerPosition:\n \t\t\t\t\t[in] the index of the next CharType to be written i.e.\n \t\t\t\t\tstr->str + *writerPosition is a pointer to the beginning\n \t\t\t\t\tof the next character position where the character with Code Point code_point will be written.\n \t\t\t\t\t[out] the next writerPosition used for any subsequent call to writeCharToString\n @return Error handling code"]
    pub fn writeCharToString(
        str_: *mut String,
        code_point: u32,
        writerPosition: *mut Index,
    ) -> errorCode;
}
extern "C" {
    #[doc = " @brief Returns the UCS [ISO/IEC 10646] code point at particular index from a String\n @param[in] str string\n @param[in, out] readerPosition:\n \t\t\t\t[in] The position that marks the beginning of the character to be read\n \t\t\t\t[out] The position of the next character to be passed to a subsequent calls to readCharFromString\n @return UCS code point"]
    pub fn readCharFromString(str_: *const String, readerPosition: *mut Index) -> u32;
}
extern "C" {
    #[doc = " @brief Creates an empty string\n @param[in, out] emptyStr empty string"]
    pub fn getEmptyString(emptyStr: *mut String);
}
extern "C" {
    #[doc = " @brief Checks if an string is empty\n @param[in] str string to check\n @return FALSE if not empty, TRUE if empty"]
    pub fn isStringEmpty(str_: *const String) -> boolean;
}
extern "C" {
    #[doc = " @brief Transform a NULL terminated string of ASCII chars to String allocating memory for the CharType*.\n @param[in] inStr ASCII stream\n @param[in, out] outStr resulted string\n @param[in, out] memList A list storing the memory allocations\n @param[in] clone Boolean indicating if outStr should reuse the memory allocated for inStr if possible.\n \t\t\t\t\tFALSE - if String implementation allows it - do not allocate new memory for the string\n \t\t\t\t\tTRUE - always allocate fresh memory for outStr and copy inStr there\n @return Error handling code"]
    pub fn asciiToString(
        inStr: *const ::std::os::raw::c_char,
        outStr: *mut String,
        memList: *mut AllocList,
        clone: boolean,
    ) -> errorCode;
}
extern "C" {
    #[doc = " @brief Tests if two strings are equal\n @param[in] str1 string to compare\n @param[in] str2 string to compare\n @return TRUE if the strings are equal, FALSE - otherwise"]
    pub fn stringEqual(str1: String, str2: String) -> boolean;
}
extern "C" {
    #[doc = " @brief Compare two strings lexicographically\n @param[in] str1 string to compare\n @param[in] str2 string to compare\n @return 0 when the strings are equal; negative int when str1<str2; positive when  str1>str2"]
    pub fn stringCompare(str1: String, str2: String) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Checks if a String string and ASCII string are equal\n @param[in] str1 string to compare\n @param[in] str2 null terminated string to compare\n @return TRUE if the strings are equal, FALSE - otherwise"]
    pub fn stringEqualToAscii(str1: String, str2: *const ::std::os::raw::c_char) -> boolean;
}
extern "C" {
    #[doc = " @brief Makes a copy of the string in a new location\n @param[in] src the string to be copied\n @param[in] newStr will point to the newly allocated memory with scr->CharType* copied there\n @return Error handling code"]
    pub fn cloneString(src: *const String, newStr: *mut String) -> errorCode;
}
extern "C" {
    #[doc = " @brief Makes a copy of the string in a new location\n @param[in] src the string to be copied\n @param[in] newStr will point to the newly allocated memory with scr->CharType* copied there\n @param[in, out] memList A list storing the memory allocations\n @return Error handling code"]
    pub fn cloneStringManaged(
        src: *const String,
        newStr: *mut String,
        memList: *mut AllocList,
    ) -> errorCode;
}
extern "C" {
    #[doc = " @brief Returns the index of the first occurrence of a character in a string\n @param[in] src the source string\n @param[in] sCh a character that is searched\n @return the index of first occurrence; INDEX_MAX if not found"]
    pub fn getIndexOfChar(src: *const String, sCh: CharType) -> Index;
}
extern "C" {
    #[doc = " @brief Converts a string to int representation. Only 10-base representation\n @param[in] src the source string\n @param[out] number the int representation of the string\n @return Error handling code"]
    pub fn stringToInteger(src: *const String, number: *mut ::std::os::raw::c_int) -> errorCode;
}
extern "C" {
    #[doc = " @brief Converts a string to int64 representation. Only 10-base representation\n @param[in] src the source string\n @param[out] number the int64 representation of the string\n @return Error handling code"]
    pub fn stringToInt64(src: *const String, number: *mut i64) -> errorCode;
}
extern "C" {
    #[doc = " @brief Converts a integer to string representation.\n Uses allocateStringMemory() so make sure to free the\n memory allocated for the string manually!\n\n @param[in] number the source integer\n @param[out] outStr the resulting string representation\n @return Error handling code"]
    pub fn integerToString(number: Integer, outStr: *mut String) -> errorCode;
}
extern "C" {
    #[doc = " @brief Converts a boolean to string representation.\n Uses allocateStringMemory() so make sure to free the\n memory allocated for the string manually!\n\n @param[in] b TRUE/FALSE\n @param[out] outStr the resulting string representation\n @return Error handling code"]
    pub fn booleanToString(b: boolean, outStr: *mut String) -> errorCode;
}
extern "C" {
    #[doc = " @brief Converts a float to string representation.\n Uses allocateStringMemory() so make sure to free the\n memory allocated for the string manually!\n\n @param[in] f float in EXI format (base 10)\n @param[out] outStr the resulting string representation\n @return Error handling code"]
    pub fn floatToString(f: Float, outStr: *mut String) -> errorCode;
}
extern "C" {
    #[doc = " @brief Converts a decimal to string representation.\n Uses allocateStringMemory() so make sure to free the\n memory allocated for the string manually!\n\n @param[in] d the source decimal\n @param[out] outStr the resulting string representation\n @return Error handling code"]
    pub fn decimalToString(d: Decimal, outStr: *mut String) -> errorCode;
}
extern "C" {
    #[doc = " @brief Converts a dateTime value to string representation.\n Uses allocateStringMemory() so make sure to free the\n memory allocated for the string manually!\n\n @param[in] dt the source dtValue\n @param[out] outStr the resulting string representation\n @return Error handling code"]
    pub fn dateTimeToString(dt: EXIPDateTime, outStr: *mut String) -> errorCode;
}
extern "C" {
    #[doc = " @brief Prints out a String\n Used for debugging purposes.\n @param[in] inStr Input string to be printed"]
    pub fn printString(inStr: *const String);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[doc = " Hashtable for fast look-up of global values in the table.\n Only used when:\n serializing &&\n valuePartitionCapacity > 50  &&   //for small table full-scan will work better\n valueMaxLength > 0 // this is essentially equal to valuePartitionCapacity == 0\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hashtable {
    pub _address: u8,
}

// encodeTestEXI.c rewrite
#[test]
fn encodeTestEXI() {
    // EXI Data
    const NS_STR: &str = "http://www.ltu.se/EISLAB/schema-test";
    const NS_NESTED_STR: &str = "http://www.ltu.se/EISLAB/nested-xsd";
    const ELEM_ENCODE_STR: &str = "EXIPEncoder";
    const ELEM_MULT_TEST_STR: &str = "MultipleXSDsTest";
    const ELEM_DESCR_STR: &str = "description";
    const ELEM_TYPE_TEST_STR: &str = "type-test";
    const ELEM_TEST_SETUP_STR: &str = "testSetup";
    const ELEM_BOOL_STR: &str = "bool";
    const ELEM_EXT_TYPES_STR: &str = "extendedTypeTest";
    const ELEM_BYTE_TYPES_STR: &str = "byteTest";
    const ELEM_DATE_TYPES_STR: &str = "dateTimeTest";
    const ELEM_BIN_TYPES_STR: &str = "binaryTest";
    const ELEM_ENUM_TYPES_STR: &str = "enumTest";
    const ATTR_BYTE_STR: &str = "testByte";
    const ATTR_VERSION_STR: &str = "version";
    const ATTR_GOAL_STR: &str = "goal";
    const ATTR_ID_STR: &str = "id";
    const SOME_BINARY_DATA_BASE64: &str = "i3sd7fatzxad";
    const ENUM_DATA_4: &str = "hej";
    const nullstr_c: StringType = StringType {
        str_: std::ptr::null::<std::os::raw::c_char>() as *mut _,
        length: 0,
    };

    unsafe {
        // test args
        let schemaPtr = std::ptr::null::<EXIPSchema>() as *mut _;

        // Stream
        let mut testStrm: MaybeUninit<EXIStream> = MaybeUninit::uninit();

        // EXI Type Class
        let mut valueType: EXITypeClass = 25;

        // Initialise buffer
        const OUTPUT_BUFFER_SIZE: usize = 519;
        let mut heap_buf = Box::new([0; OUTPUT_BUFFER_SIZE]);
        let buf = BinaryBuffer {
            buf: heap_buf.as_mut_ptr(),
            bufLen: OUTPUT_BUFFER_SIZE,
            bufContent: 0,
            ioStrm: ioStream {
                readWriteToStream: None,
                stream: std::ptr::null_mut(),
            },
        };

        // 1. Initialise the header of the stream
        (serialize.initHeader).unwrap()(testStrm.as_mut_ptr());
        let ptr = testStrm.as_mut_ptr();

        // 2. Set any options in the header
        (*ptr).header.has_cookie = 1;
        (*ptr).header.has_options = 1;
        (*ptr).header.opts.valueMaxLength = 300;
        (*ptr).header.opts.valuePartitionCapacity = 50;
        (*ptr).header.opts.enumOpt |= 2; // set strict
        let mut testStrm = testStrm.assume_init();

        // 4. Initialise Stream
        let ec = initStream(&mut testStrm as *mut _, buf, schemaPtr);
        assert_eq!(ec, 0);

        // 5. Start building
        let ec = (serialize.exiHeader).unwrap()(&mut testStrm as *mut _);
        assert_eq!(ec, 0);

        let ec = (serialize.startDocument).unwrap()(&mut testStrm as *mut _);
        assert_eq!(ec, 0);

        // let ns_str_c = CString::new(NS_STR).unwrap();
        let ns_str_c = StringType {
            str_: NS_STR.as_ptr() as *mut _,
            length: NS_STR.len(),
        };
        let qname = QName {
            uri: &ns_str_c,
            localName: &StringType {
                str_: ELEM_MULT_TEST_STR.as_ptr() as *mut _,
                length: ELEM_MULT_TEST_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };
        let ec = (serialize.startElement).unwrap()(
            &mut testStrm as *mut _,
            qname,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        let qname = QName {
            uri: &ns_str_c,
            localName: &StringType {
                str_: ELEM_ENCODE_STR.as_ptr() as *mut _,
                length: ELEM_ENCODE_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };

        let ec = (serialize.startElement).unwrap()(
            &mut testStrm as *mut _,
            qname,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        // null uri, attr byte local name
        let qname = QName {
            uri: &nullstr_c,
            localName: &StringType {
                str_: ATTR_BYTE_STR.as_ptr() as *mut _,
                length: ATTR_BYTE_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };
        let ec = (serialize.attribute).unwrap()(
            &mut testStrm as *mut _,
            qname,
            1,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        let mut chVal = nullstr_c.clone();
        let fiftyfive = c"55";
        let ec = asciiToString(
            fiftyfive.as_ptr(),
            &mut chVal as *mut _,
            &mut testStrm.memList as *mut _,
            0,
        );
        assert_eq!(ec, 0);
        assert_eq!(
            [53, 53],
            std::slice::from_raw_parts(chVal.str_, chVal.length)
        );

        let ec = (serialize.stringData).unwrap()(&mut testStrm as *mut _, chVal);
        assert_eq!(ec, 0);

        let qname = QName {
            uri: &nullstr_c,
            localName: &StringType {
                str_: ATTR_VERSION_STR.as_ptr() as *mut _,
                length: ATTR_VERSION_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };
        let ec = (serialize.attribute).unwrap()(
            &mut testStrm as *mut _,
            qname,
            1,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        let pointtwo = c"0.2";
        let ec = asciiToString(
            pointtwo.as_ptr(),
            &mut chVal as *mut _,
            &mut testStrm.memList as *mut _,
            0,
        );
        assert_eq!(ec, 0);
        assert_eq!(
            [0x30, 0x2e, 0x32],
            std::slice::from_raw_parts(chVal.str_, chVal.length)
        );

        let ec = (serialize.stringData).unwrap()(&mut testStrm as *mut _, chVal);
        assert_eq!(ec, 0);

        let example = c"This is an example of serializing EXI streams using EXIP low level API";
        let ec = asciiToString(
            example.as_ptr(),
            &mut chVal as *mut _,
            &mut testStrm.memList as *mut _,
            0,
        );
        assert_eq!(ec, 0);
        assert_eq!(
            [
                0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x61,
                0x6d, 0x70, 0x6c, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c,
                0x69, 0x7a, 0x69, 0x6e, 0x67, 0x20, 0x45, 0x58, 0x49, 0x20, 0x73, 0x74, 0x72, 0x65,
                0x61, 0x6d, 0x73, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x45, 0x58, 0x49, 0x50,
                0x20, 0x6c, 0x6f, 0x77, 0x20, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x20, 0x41, 0x50, 0x49
            ],
            std::slice::from_raw_parts(chVal.str_, chVal.length)
        );

        let ec = (serialize.stringData).unwrap()(&mut testStrm as *mut _, chVal);
        assert_eq!(ec, 0);

        let ec = (serialize.endElement).unwrap()(&mut testStrm as *mut _);
        assert_eq!(ec, 0);

        let qname = QName {
            uri: &ns_str_c,
            localName: &StringType {
                str_: ELEM_DESCR_STR.as_ptr() as *mut _,
                length: ELEM_DESCR_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };

        let ec = (serialize.startElement).unwrap()(
            &mut testStrm as *mut _,
            qname,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        let test = c"This is a test of processing XML schemes with multiple XSD files";
        let ec = asciiToString(
            test.as_ptr(),
            &mut chVal as *mut _,
            &mut testStrm.memList as *mut _,
            0,
        );
        assert_eq!(ec, 0);
        assert_eq!(
            [
                0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x74, 0x65, 0x73, 0x74,
                0x20, 0x6f, 0x66, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6e, 0x67,
                0x20, 0x58, 0x4d, 0x4c, 0x20, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73, 0x20, 0x77,
                0x69, 0x74, 0x68, 0x20, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x20, 0x58,
                0x53, 0x44, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x73
            ],
            std::slice::from_raw_parts(chVal.str_, chVal.length)
        );

        let ec = (serialize.stringData).unwrap()(&mut testStrm as *mut _, chVal);
        assert_eq!(ec, 0);

        let ec = (serialize.endElement).unwrap()(&mut testStrm as *mut _);
        assert_eq!(ec, 0);

        let qname = QName {
            uri: &StringType {
                str_: NS_NESTED_STR.as_ptr() as *mut _,
                length: NS_NESTED_STR.len(),
            },
            localName: &StringType {
                str_: ELEM_TEST_SETUP_STR.as_ptr() as *mut _,
                length: ELEM_TEST_SETUP_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };

        let ec = (serialize.startElement).unwrap()(
            &mut testStrm as *mut _,
            qname,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);

        let qname = QName {
            uri: &nullstr_c,
            localName: &StringType {
                str_: ATTR_GOAL_STR.as_ptr() as *mut _,
                length: ATTR_GOAL_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };

        let ec = (serialize.attribute).unwrap()(
            &mut testStrm as *mut _,
            qname,
            1,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        let verify = c"Verify that the implementation works!";
        let ec = asciiToString(
            verify.as_ptr(),
            &mut chVal as *mut _,
            &mut testStrm.memList as *mut _,
            0,
        );
        assert_eq!(ec, 0);
        assert_eq!(
            [
                0x56, 0x65, 0x72, 0x69, 0x66, 0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68,
                0x65, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69,
                0x6f, 0x6e, 0x20, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x21
            ],
            std::slice::from_raw_parts(chVal.str_, chVal.length)
        );

        let ec = (serialize.stringData).unwrap()(&mut testStrm as *mut _, chVal);
        assert_eq!(ec, 0);

        let simple = c"Simple test element with single attribute";
        let ec = asciiToString(
            simple.as_ptr(),
            &mut chVal as *mut _,
            &mut testStrm.memList as *mut _,
            0,
        );
        assert_eq!(ec, 0);
        assert_eq!(
            [
                0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x65, 0x6c,
                0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 0x69, 0x6e,
                0x67, 0x6c, 0x65, 0x20, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65
            ],
            std::slice::from_raw_parts(chVal.str_, chVal.length)
        );

        let ec = (serialize.stringData).unwrap()(&mut testStrm as *mut _, chVal);
        assert_eq!(ec, 0);

        let ec = (serialize.endElement).unwrap()(&mut testStrm as *mut _); // </testSetup>
        assert_eq!(ec, 0);

        let qname = QName {
            uri: &ns_str_c,
            localName: &StringType {
                str_: ELEM_TYPE_TEST_STR.as_ptr() as *mut _,
                length: ELEM_TYPE_TEST_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };

        let ec = (serialize.startElement).unwrap()(
            &mut testStrm as *mut _,
            qname,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        let qname = QName {
            uri: &nullstr_c,
            localName: &StringType {
                str_: ATTR_ID_STR.as_ptr() as *mut _,
                length: ATTR_ID_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };

        let ec = (serialize.attribute).unwrap()(
            &mut testStrm as *mut _,
            qname,
            1,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        let id = c"1001";
        let ec = asciiToString(
            id.as_ptr(),
            &mut chVal as *mut _,
            &mut testStrm.memList as *mut _,
            0,
        );
        assert_eq!(ec, 0);
        assert_eq!(
            [0x31, 0x30, 0x30, 0x31],
            std::slice::from_raw_parts(chVal.str_, chVal.length)
        );

        let ec = (serialize.stringData).unwrap()(&mut testStrm as *mut _, chVal);
        assert_eq!(ec, 0);

        let qname = QName {
            uri: &StringType {
                str_: NS_NESTED_STR.as_ptr() as *mut _,
                length: NS_NESTED_STR.len(),
            },
            localName: &StringType {
                str_: ELEM_BOOL_STR.as_ptr() as *mut _,
                length: ELEM_BOOL_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };

        let ec = (serialize.startElement).unwrap()(
            &mut testStrm as *mut _,
            qname,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        let t = c"true";
        let ec = asciiToString(
            t.as_ptr(),
            &mut chVal as *mut _,
            &mut testStrm.memList as *mut _,
            0,
        );
        assert_eq!(ec, 0);
        assert_eq!(
            [0x74, 0x72, 0x75, 0x65],
            std::slice::from_raw_parts(chVal.str_, chVal.length)
        );

        let ec = (serialize.stringData).unwrap()(&mut testStrm as *mut _, chVal);
        assert_eq!(ec, 0);

        let ec = (serialize.endElement).unwrap()(&mut testStrm as *mut _); // </bool>
        assert_eq!(ec, 0);

        let ec = (serialize.endElement).unwrap()(&mut testStrm as *mut _); // </type-test>
        assert_eq!(ec, 0);

        let qname = QName {
            uri: &ns_str_c,
            localName: &StringType {
                str_: ELEM_EXT_TYPES_STR.as_ptr() as *mut _,
                length: ELEM_EXT_TYPES_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };

        let ec = (serialize.startElement).unwrap()(
            &mut testStrm as *mut _,
            qname,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        let qname = QName {
            uri: &nullstr_c,
            localName: &StringType {
                str_: ELEM_BYTE_TYPES_STR.as_ptr() as *mut _,
                length: ELEM_BYTE_TYPES_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };

        // <byteTest>
        let ec = (serialize.startElement).unwrap()(
            &mut testStrm as *mut _,
            qname,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        let eleven = c"11";
        let ec = asciiToString(
            eleven.as_ptr(),
            &mut chVal as *mut _,
            &mut testStrm.memList as *mut _,
            0,
        );
        assert_eq!(ec, 0);
        assert_eq!(
            [0x31, 0x31],
            std::slice::from_raw_parts(chVal.str_, chVal.length)
        );

        let ec = (serialize.stringData).unwrap()(&mut testStrm as *mut _, chVal);
        assert_eq!(ec, 0);

        let ec = (serialize.endElement).unwrap()(&mut testStrm as *mut _); // </byteTest>
        assert_eq!(ec, 0);

        let qname = QName {
            uri: &nullstr_c,
            localName: &StringType {
                str_: ELEM_DATE_TYPES_STR.as_ptr() as *mut _,
                length: ELEM_DATE_TYPES_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };

        // <dateTimeTest>
        let ec = (serialize.startElement).unwrap()(
            &mut testStrm as *mut _,
            qname,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        let time = c"2012 Jul 31 13:33";
        let ec = asciiToString(
            time.as_ptr(),
            &mut chVal as *mut _,
            &mut testStrm.memList as *mut _,
            0,
        );
        assert_eq!(ec, 0);
        assert_eq!(
            [
                0x32, 0x30, 0x31, 0x32, 0x20, 0x4a, 0x75, 0x6c, 0x20, 0x33, 0x31, 0x20, 0x31, 0x33,
                0x3a, 0x33, 0x33
            ],
            std::slice::from_raw_parts(chVal.str_, chVal.length)
        );

        let ec = (serialize.stringData).unwrap()(&mut testStrm as *mut _, chVal);
        assert_eq!(ec, 0);

        let ec = (serialize.endElement).unwrap()(&mut testStrm as *mut _); // </dateTimeTest>
        assert_eq!(ec, 0);

        let qname = QName {
            uri: &nullstr_c,
            localName: &StringType {
                str_: ELEM_BIN_TYPES_STR.as_ptr() as *mut _,
                length: ELEM_BIN_TYPES_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };

        // <binaryTest>
        let ec = (serialize.startElement).unwrap()(
            &mut testStrm as *mut _,
            qname,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        let b64_data = CString::new(SOME_BINARY_DATA_BASE64).unwrap();
        let ec = (serialize.stringData).unwrap()(
            &mut testStrm as *mut _,
            StringType {
                str_: b64_data.as_ptr() as *mut _,
                length: SOME_BINARY_DATA_BASE64.len(),
            },
        );
        assert_eq!(ec, 0);

        let ec = (serialize.endElement).unwrap()(&mut testStrm as *mut _); // </binaryTest>
        assert_eq!(ec, 0);

        let qname = QName {
            uri: &nullstr_c,
            localName: &StringType {
                str_: ELEM_ENUM_TYPES_STR.as_ptr() as *mut _,
                length: ELEM_ENUM_TYPES_STR.len(),
            },
            prefix: std::ptr::null_mut(),
        };

        let ec = (serialize.startElement).unwrap()(
            &mut testStrm as *mut _,
            qname,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);
        assert_eq!(valueType, 0);

        let enum_data_4 = CString::new(ENUM_DATA_4).unwrap();
        let ec = (serialize.stringData).unwrap()(
            &mut testStrm as *mut _,
            StringType {
                str_: enum_data_4.as_ptr() as *mut _,
                length: ENUM_DATA_4.len(),
            },
        );
        assert_eq!(ec, 0);

        let ec = (serialize.endElement).unwrap()(&mut testStrm as *mut _); // </enumTest>
        assert_eq!(ec, 0);

        let ec = (serialize.endElement).unwrap()(&mut testStrm as *mut _); // </extendedTypeTest>
        assert_eq!(ec, 0);

        let ec = (serialize.endElement).unwrap()(&mut testStrm as *mut _); // </MultipleXSDsTest>
        assert_eq!(ec, 0);

        let ec = (serialize.endDocument).unwrap()(&mut testStrm as *mut _);
        assert_eq!(ec, 0);

        assert_eq!(
            [
                36, 69, 88, 73, 160, 2, 172, 2, 12, 178, 18, 52, 58, 58, 56, 29, 23, 151, 187, 187,
                187, 151, 54, 58, 58, 151, 57, 178, 151, 162, 164, 169, 166, 32, 161, 23, 185, 177,
                180, 50, 182, 176, 150, 186, 50, 185, 186, 8, 166, 186, 182, 58, 52, 184, 54, 50,
                172, 41, 162, 57, 170, 50, 185, 186, 80, 49, 21, 97, 37, 65, 21, 185, 141, 189,
                145, 149, 201, 33, 46, 140, 174, 110, 136, 79, 46, 140, 160, 134, 166, 180, 132,
                59, 50, 185, 57, 180, 183, 183, 2, 152, 23, 25, 90, 66, 163, 67, 75, 153, 3, 75,
                153, 3, 11, 113, 3, 43, 195, 11, 107, 131, 99, 41, 3, 123, 49, 3, 155, 43, 147, 75,
                11, 99, 75, 211, 75, 115, 57, 2, 42, 194, 73, 3, 155, 163, 147, 43, 11, 107, 153,
                3, 171, 155, 75, 115, 57, 2, 42, 194, 74, 129, 3, 99, 123, 185, 3, 99, 43, 179, 43,
                97, 2, 10, 130, 74, 129, 140, 140, 174, 108, 110, 77, 46, 14, 141, 45, 237, 218,
                18, 163, 67, 75, 153, 3, 75, 153, 3, 9, 3, 163, 43, 155, 161, 3, 123, 49, 3, 131,
                147, 123, 27, 43, 155, 155, 75, 115, 57, 2, 194, 106, 97, 3, 155, 27, 67, 43, 107,
                43, 153, 3, 187, 75, 163, 65, 3, 107, 171, 99, 163, 75, 131, 99, 41, 2, 194, 154,
                33, 3, 51, 75, 99, 43, 154, 2, 54, 135, 71, 71, 3, 162, 242, 247, 119, 119, 114,
                230, 199, 71, 82, 231, 54, 82, 244, 84, 149, 52, 196, 20, 34, 246, 230, 87, 55, 70,
                86, 66, 215, 135, 54, 64, 167, 70, 87, 55, 69, 54, 87, 71, 87, 4, 130, 179, 183,
                176, 182, 19, 171, 50, 185, 52, 179, 60, 144, 58, 52, 48, 186, 16, 58, 52, 50, 144,
                52, 182, 184, 54, 50, 182, 178, 183, 58, 48, 186, 52, 183, 183, 16, 59, 183, 185,
                53, 185, 144, 242, 181, 54, 150, 215, 6, 198, 82, 7, 70, 87, 55, 66, 6, 86, 198,
                86, 214, 86, 231, 66, 7, 118, 151, 70, 130, 7, 54, 150, 230, 118, 198, 82, 6, 23,
                71, 71, 38, 150, 39, 87, 70, 86, 129, 78, 143, 46, 12, 165, 174, 140, 174, 110,
                137, 3, 105, 100, 6, 49, 48, 48, 49, 212, 21, 137, 189, 189, 179, 6, 116, 114, 117,
                101, 34, 8, 178, 188, 58, 50, 183, 50, 50, 178, 42, 60, 184, 50, 170, 50, 185, 186,
                68, 37, 137, 229, 209, 149, 81, 149, 205, 211, 4, 49, 49, 68, 53, 145, 133, 209,
                149, 81, 165, 181, 149, 81, 149, 205, 211, 19, 50, 48, 49, 50, 32, 74, 117, 108,
                32, 51, 49, 32, 49, 51, 58, 51, 51, 66, 22, 196, 210, 220, 194, 228, 242, 168, 202,
                230, 233, 135, 52, 153, 185, 178, 27, 179, 48, 186, 61, 60, 48, 178, 49, 9, 101,
                110, 117, 109, 84, 101, 115, 116, 193, 90, 25, 90, 142, 0
            ],
            std::slice::from_raw_parts(testStrm.buffer.buf as *mut u8, testStrm.buffer.bufContent)
        );

        let ec = (serialize.closeEXIStream).unwrap()(&mut testStrm as *mut _);
        assert_eq!(ec, 0);
    }
}

#[test]
fn simple_raw() {
    const NS_STR: &str = "http://www.ltu.se/EISLAB/schema-test";
    const ELEM_MULT_TEST_STR: &str = "MultipleXSDsTest";

    const nullstr_c: StringType = StringType {
        str_: std::ptr::null::<std::os::raw::c_char>() as *mut _,
        length: 0,
    };
    unsafe {
        // test args
        let schemaPtr = std::ptr::null::<EXIPSchema>() as *mut _;

        // Stream
        let mut testStrm: MaybeUninit<EXIStream> = MaybeUninit::uninit();

        // EXI Type Class
        let mut valueType: EXITypeClass = 25;

        // Initialise buffer
        const OUTPUT_BUFFER_SIZE: usize = 1000;
        let mut out_buf: Vec<i8> = vec![0; OUTPUT_BUFFER_SIZE];
        let buf = BinaryBuffer {
            buf: out_buf.as_mut_ptr(),
            bufLen: OUTPUT_BUFFER_SIZE,
            bufContent: 0,
            ioStrm: ioStream {
                readWriteToStream: None,
                stream: std::ptr::null_mut(),
            },
        };

        // 1. Initialise the header of the stream
        (serialize.initHeader).unwrap()(testStrm.as_mut_ptr());
        let ptr = testStrm.as_mut_ptr();

        // 2. Set any options in the header
        (*ptr).header.has_cookie = 1;
        (*ptr).header.has_options = 1;
        (*ptr).header.opts.valueMaxLength = 300;
        (*ptr).header.opts.valuePartitionCapacity = 50;
        (*ptr).header.opts.enumOpt |= 2; // set strict
        let mut testStrm = testStrm.assume_init();

        // 4. Initialise Stream
        let ec = initStream(&mut testStrm as *mut _, buf, schemaPtr);
        assert_eq!(ec, 0);

        let ec = (serialize.exiHeader).unwrap()(&mut testStrm as *mut _);
        assert_eq!(ec, 0);

        let ec = (serialize.startDocument).unwrap()(&mut testStrm as *mut _);
        assert_eq!(ec, 0);

        // let ns_str_c = CString::new(NS_STR).unwrap();
        let ns_str_c = StringType {
            str_: NS_STR.as_ptr() as *mut _,
            length: NS_STR.len(),
        };
        let qname = QName {
            uri: &ns_str_c,
            localName: &StringType {
                str_: ELEM_MULT_TEST_STR.as_ptr() as *mut _,
                length: ELEM_MULT_TEST_STR.len(),
            },
            prefix: std::ptr::null(),
        };
        let ec = (serialize.startElement).unwrap()(
            &mut testStrm as *mut _,
            qname,
            &mut valueType as *mut _,
        );
        assert_eq!(ec, 0);

        let mut chVal = nullstr_c.clone();
        let example = c"This is an example of serializing EXI streams using EXIP low level API";
        let ec = asciiToString(
            example.as_ptr(),
            &mut chVal as *mut _,
            &mut testStrm.memList as *mut _,
            0,
        );
        assert_eq!(ec, 0);
        assert_eq!(
            [
                0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x61,
                0x6d, 0x70, 0x6c, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c,
                0x69, 0x7a, 0x69, 0x6e, 0x67, 0x20, 0x45, 0x58, 0x49, 0x20, 0x73, 0x74, 0x72, 0x65,
                0x61, 0x6d, 0x73, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x45, 0x58, 0x49, 0x50,
                0x20, 0x6c, 0x6f, 0x77, 0x20, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x20, 0x41, 0x50, 0x49
            ],
            std::slice::from_raw_parts(chVal.str_, chVal.length)
        );

        let ec = (serialize.stringData).unwrap()(&mut testStrm as *mut _, chVal);
        assert_eq!(ec, 0);

        let ec = (serialize.endElement).unwrap()(&mut testStrm as *mut _);
        assert_eq!(ec, 0);

        let ec = (serialize.endDocument).unwrap()(&mut testStrm as *mut _);
        assert_eq!(ec, 0);

        assert_eq!(
            [
                36, 69, 88, 73, 160, 2, 172, 2, 12, 178, 18, 52, 58, 58, 56, 29, 23, 151, 187, 187,
                187, 151, 54, 58, 58, 151, 57, 178, 151, 162, 164, 169, 166, 32, 161, 23, 185, 177,
                180, 50, 182, 176, 150, 186, 50, 185, 186, 8, 166, 186, 182, 58, 52, 184, 54, 50,
                172, 41, 162, 57, 170, 50, 185, 186, 105, 10, 141, 13, 46, 100, 13, 46, 100, 12,
                45, 196, 12, 175, 12, 45, 174, 13, 140, 164, 13, 236, 196, 14, 108, 174, 77, 44,
                45, 141, 47, 77, 45, 204, 228, 8, 171, 9, 36, 14, 110, 142, 76, 172, 45, 174, 100,
                14, 174, 109, 45, 204, 228, 8, 171, 9, 42, 4, 13, 141, 238, 228, 13, 140, 174, 204,
                173, 132, 8, 42, 9, 32
            ],
            std::slice::from_raw_parts(testStrm.buffer.buf as *mut u8, testStrm.buffer.bufContent)
        );

        let ec = (serialize.closeEXIStream).unwrap()(&mut testStrm as *mut _);
        assert_eq!(ec, 0);
    }
}
